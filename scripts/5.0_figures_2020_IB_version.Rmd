---
title: "Figures"
author: "Indra Boving"
date: "12/17/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#lots of extra here, but oh well... 
library(ggplot2)
library(gapminder)
library(data.table)
library(purrr) #for visualizing all variables in one big plot
library(naniar) #for dealing with NAs nicely 
library(tidyverse)
library(devtools)
library(ggfortify)
library(ggpubr)
library(jtools)
library(lmerTest)
library(ggeffects) 
library(GGally) #for corr plots
require(kimisc) # has the nlist function to create a named list
require(AICcmodavg) # has the aictab function
library(psych)
#devtools::install_github("strengejacke/strengejacke")
library(strengejacke)
library(sjPlot) # table functions
library(sjmisc) # sample data
library(lme4) # fitting models
library(here)
library(effects) #for plotting model effects
library(sjstats) #use for r2 functions
library(TMB)
library(glmmTMB)
library(lattice)
library(equatiomatic)
library("broom.mixed")
library(ggbiplot)
select = dplyr::select
here = here::here
library(MuMIn)
library(modelsummary)
#install_github("BlakeRMills/MetBrewer") 
#library("BlakeRMills/MetBrewer")
library(segmented)
filter = dplyr::filter
library(MetBrewer)
library(performance)
library(GGally)
```

Set global options for color palettes: 

```{r}
# scale_colour_continuous <- function(...) scale_color_brewer(palette="Dark2")
# scale_colour_discrete   <- function(...) scale_color_brewer(palette="Dark2")
# scale_colour_binned     <- function(...) scale_color_brewer(palette="Dark2")
th <- theme(panel.background = element_rect(fill='white', colour='black'), # Make background white and border black
          panel.grid.major = element_blank(),  # Hide major gridlines
          panel.grid.minor = element_blank())
```

# 1.1. PCA

###2020 only 
```{r warning=FALSE}
### Note: This dataset includes only Epiradiator and Ignited samples
epi.flamdata.2020 <- read_csv(here("processed-data", "compiled-datasets", "LOCAL", "mem.data.local.epi.alldates.csv")) %>%
  #mutate(LFM = lfm.NAs.imputed) %>% #this doesn't matter because we dont use LFM in the PCAs
  filter(year == 2020) %>% 
  mutate(LFM = lfm.NAs.imputed) %>% 
  filter(ignition == 1, model == "EPI")

 # filter(year == 2020)

figure_epi_pca_quant.2020 <- (epi.flamdata.2020[, c("fh", "ttfg", "tti", "fd", "gd", "gti", "pfg",
         "temp.max")]) %>%  
  # transmute(
  #   "Flame Height" = fh,
  #    "Max. Temp" = temp.max,
  #    "\n\nTime to Ignition" = tti, #space is added in front of TTI so that the labels dont overlap in the figure
  #    "Flame Duration" = fd,
  #   "\nTime to First Glow" = ttfg,
  #  "Glow to Ignition" = gti,
  #   "Glow Duration" = gd,
  #   "Post-flame Glow" = pfg)
  
## Changing the order of the variables changes the PCA ordering: 
  # 
  # transmute("\nTime to First Glow" = ttfg,
  #           "Glow to Ignition" = gti,
  #           "\n\nTime to Ignition" = tti,
  #           "Flame Height" = fh,
  #           "Flame Duration" = fd,
  #           "Max. Temp" = temp.max,
  #         "Post-flame Glow" = pfg,
  #          "Glow Duration" = gd,
  #         )
  # transmute(
  #           "Glow Duration" = gd,
  #         "Post-flame Glow" = pfg,
  #          "Max. Temp" = temp.max,
  #         "Flame Duration" = fd,
  #          "Flame Height" = fh,
  #         "\n\nTime to Ignition" = tti,
  #         "Glow to Ignition" = gti,
  #         "\nTime to First Glow" = ttfg
  #         )
 transmute( "Flame Duration" = fd,
           "Flame Height" = fh,
           "Post-flame Glow" = pfg,
          "\n\nTime to Ignition" = tti,
          "Max. Temp" = temp.max,
            "Glow Duration" = gd,
          "Glow to Ignition" = gti,
          "\nTime to First Glow" = ttfg
          )

figure_epi_pca_cat.2020 <- (epi.flamdata.2020[c("hydration", "spp", "year.month", "sample")]) %>% 
  transmute("Hydration" = hydration, 
            spp = spp,
            "Timing" = year.month, 
            "Sample" = sample) %>% 
  mutate(Species = case_when(
    spp == "ADFA" ~ "A. fasciculatum", 
    spp == "CEME" ~ "C. megacarpus"
  ))

figure_prcomp.2020 <- prcomp(na.omit(figure_epi_pca_quant.2020), center = TRUE, scale = TRUE, retx=TRUE)


#### biplot PCA plot


# g <- ggbiplot(figure_prcomp, 
#                         groups = figure_epi_pca_cat$Species, 
#                         obs.scale = 0, 
#                         var.scale = 1,  
#                         circle = TRUE, 
#                         #ellipse = TRUE,
#                         size = .5,
#                         varname.size = 2.7, 
#                         alpha = 0, 
#                         labels.size = 2.7,
#                         varname.adjust = 1.5, 
#                         expand= TRUE) +
#   geom_point(aes(colour=figure_epi_pca_cat$Species), size = .5) +# by spp
# ggtitle("Flammability metrics only") +
#   scale_color_brewer(palette = "Dark2") +
#   #scale_color_manual(values=met.brewer("Morgenstern", 2)) +
#  # geom_text_repel(data=filter(results, padj<0.05), aes(label=Gene))
#   th
# g

#-----------------------------------
### *ggplot PCA plot (USE THIS)

#Setting up plotting data: 

#decisions for plotting:
choices = 1:2 
scale = 1
obs.scale = 1 - scale
var.scale = scale
ellipse.prob = 0.68
labels.size = 3
circle.prob = 0.69
choices = 1:2

#Run PCA
pcobj <- prcomp(na.omit(figure_epi_pca_quant.2020), center = TRUE, scale = TRUE)

# extract PCA components: 
nobs.factor <- sqrt(nrow(pcobj$x) - 1)
    d <- pcobj$sdev
    u <- sweep(pcobj$x, 2, 1/(d * nobs.factor), FUN = "*")
    v <- pcobj$rotation

  choices <- pmin(choices, ncol(u))
  df.u <- as.data.frame(sweep(u[, choices], 2, d[choices]^obs.scale, 
                              FUN = "*"))
  v <- sweep(v, 2, d^var.scale, FUN = "*")
  df.v <- as.data.frame(v[, choices])
  names(df.u) <- c("PC1", "PC2")
  names(df.v) <- names(df.u)
  df.u <- df.u * nobs.factor

  r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)
  
###trying to add ellipse here!
#ell <- sqrt(qchisq(ellipse.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)
  
v.scale <- rowSums(v^2)
df.v <- r * df.v/sqrt(max(v.scale)) 
df.v <- df.v %>% mutate(PC1, PC2)
df.v$Variables <- rownames(v) 
PCAloadings = df.v
#df.v = dataset with loadings 

  #dataset with scores and categorical variables for plotting points: 
PCAvalues <- cbind(df.u, figure_epi_pca_cat.2020)

#dataset with information for plotting circle: 
theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))

circle <- data.frame(PC1 = r * cos(theta), PC2 = r * sin(theta)) 

#ellipse <- data.frame(PC1 = ell * cos(theta), PC2 = ell * sin(theta)) 

#Group by flam. metric: 
PCA_combustability <- df.v %>% 
  filter(Variables %in% c("Flame Height", "Max. Temp","Flame Duration"))
         
PCA_ignitability <- df.v %>% 
  filter(Variables %in% c("\n\nTime to Ignition", "Glow to Ignition"))

PCA_consumability <- df.v %>% 
  filter(Variables %in% c("Glow Duration", "Post-flame Glow", "\nTime to First Glow"))

# Calculate the angles and the label offset
df.v$Angle = ((180/pi) * atan(df.v$PC2/df.v$PC1))

df.v$Offset <- ((-2 * sign(df.v$PC1))/2)

#labels: 
u.axis.labs <- paste("PC", choices, sep = "")
u.axis.labs <- paste(u.axis.labs, sprintf("(%0.1f%% explained var.)", 
                                            100 * pcobj$sdev[choices]^2/sum(pcobj$sdev^2)))

# Plot
ggplot(PCAvalues, aes(x = PC1, y = PC2)) +
  #stat_ellipse(level = 0.95, size = 1, show.legend = FALSE) +
  geom_point(size = 1, alpha = .3, aes(shape = Species
                                       #, color = Species
                                       ), data = PCAvalues) +
  geom_segment(data = PCA_combustability, aes(x = 0, y = 0, 
                                              xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
      size = .8, 
     color = "#a56457") +
  geom_segment(data = PCA_consumability, aes(x = 0, y = 0,
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .8, 
     color = "#b08ba5") +
  geom_segment(data = PCA_ignitability, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), 
     size = .8, 
     color = "#ffb178") +
  annotate("text", 
           x = (PCA_combustability$PC1 * 1.2), 
          y = (PCA_combustability$PC2 * 1.2),
          label = PCA_combustability$Variables, size = 2.6) +
  annotate("text",
           x = (PCA_ignitability$PC1 * 1.4), 
           y = (PCA_ignitability$PC2 * 1.5), 
           label = PCA_ignitability$Variables, size = 2.6) +
  annotate("text",
           x = (PCA_consumability$PC1 * 1.3),
           y = (PCA_consumability$PC2 * 1.1), 
           label = PCA_consumability$Variables, size = 3) + 
  theme(panel.background = element_rect(fill='white', colour='black'), # Make background white and border black
          panel.grid.major = element_blank(),  # Hide major gridlines
          panel.grid.minor = element_blank()) +
  #th +
  scale_color_manual(values = c("#b08ba5","#db8872")) + 
  geom_path(data = circle, color = "black",  size = 1/2, alpha = 1/3) + 
  #geom_path(data = ellipse, color = "black",  size = 1/2, alpha = 1/3) + 
  xlab(u.axis.labs[1]) + 
   ylab(u.axis.labs[2]) +
  coord_equal()
```

```{r warning=FALSE}
##Add scores to dataset: 
x.flam <-predict(pcobj)  ### generate scores for each row in epi.flamdata

pca.flam.data.2020 <- as.data.frame(x.flam) 

all.data.epi <- cbind(epi.flamdata.2020, pca.flam.data.2020)

# #because we wants instances where they didn't ignite for the logistic regression: 
epi.flamdata_noignitions.2020 <- read_csv(here("processed-data", "compiled-datasets", "LOCAL",  "local_flam_data_all.csv")) %>%
  mutate(LFM = lfm.NAs.imputed) %>%
  filter(year == 2020) %>%
  filter(model == "EPI") %>%
  filter(ignition == 0)

all.data.withnoignitions.2020 <- bind_rows(all.data.epi, epi.flamdata_noignitions.2020)

#dataset with the above columns, PCA using imputed NAs (medians), and flam metrics with NAs still in there:
mem.data.2020 <- all.data.withnoignitions.2020
#%>% select(individual, site, year, month, year.month, lfm.outliers.out, lfm.NAs.imputed, mpa, dw.flam.sample, ww.flam.sample, sample.wt, spp, start.temp,  gww.gdw.saturated, gdw.gww.saturated, fd, fh, gd, gti, pfg, dry.norm.fd, dry.norm.fh, dry.norm.gd, dry.norm.gti, dry.norm.pfg, temp.max, ttfg, tti, temp.change, PC1, PC2, PC3, PC4, model, LFM, prop.ignite, bins10lfm, flam.index, precip.2mo, prop.ignite.bins5, data.10bins_nodate, data.5bins_nodate)
```

#DATASET

```{r warning=FALSE}
write_csv(mem.data, here("processed-data", "compiled-datasets", "LOCAL", "mem.data.local.epi.2020.csv"))
```


#1.2. PCA Table

```{r warning=FALSE}
# figure_epi_pca_quant <- (epi.flamdata[, c("fh", "ttfg", "tti", "fd", "gd", "gti", "pfg",
#          "temp.max")]) %>% 
  # transmute("\nTime to First Glow" = ttfg,
  #           "Glow to Ignition" = gti,
  #           "\n\nTime to Ignition" = tti,
  #           "Flame Height" = fh,
  #           "Flame Duration" = fd,
  #           "Max. Temp" = temp.max,
  #         "Post-flame Glow" = pfg,
  #          "Glow Duration" = gd,
  #         )
  # transmute(
  #           "Glow Duration" = gd, 
  #         "Post-flame Glow" = pfg,
  #          "Max. Temp" = temp.max,
  #         "Flame Duration" = fd,
  #          "Flame Height" = fh,
  #         "\n\nTime to Ignition" = tti, 
  #         "Glow to Ignition" = gti, 
  #         "\nTime to First Glow" = ttfg
  #         )
  # transmute(
  #   "Flame Height" = fh,
  #    "Max. Temp" = temp.max,
  #    "\n\nTime to Ignition" = tti,
  #    "Flame Duration" = fd,
  #   "\nTime to First Glow" = ttfg,
  #   "Glow to Ignition" = gti,
  #   "Glow Duration" = gd,
  #   "Post-flame Glow" = pfg)
  

figure_epi_pca_cat.2020 <- (epi.flamdata.2020[c("hydration", "spp", "year.month", "sample")]) %>% 
  transmute("Hydration" = hydration, 
            spp = spp,
            "Timing" = year.month, 
            "Sample" = sample) %>% 
  mutate(Species = case_when(
    spp == "ADFA" ~ "A. fasciculatum", 
    spp == "CEME" ~ "C. megacarpus"
  ))

#colnames(wine_subset)[2] <- "\nFlav"  # new line

#figure_prcomp <- prcomp(na.omit(figure_epi_pca_quant), center = TRUE, scale = TRUE, retx=TRUE)

figure_varimax <- varimax(pcobj$rotation[,1:3])
figure_varimax
#summary(epi.flamdata.pca) #importance of components
#plot(epi.flamdata.pca)

tab_pca(pcobj, 
        rotation = c("varimax"), 
        digits = 2,
        show.var = TRUE,
  string.pov = "Proportion of Variance",
  string.cpov = "Cumulative Proportion") 



```

####ADFA

Setting up plotting data: 

```{r warning=FALSE}
### Note: This dataset includes only Epiradiator and Ignited samples
epi.flamdata.2020 <- read_csv(here("processed-data", "compiled-datasets", "LOCAL", "mem.data.local.epi.alldates.csv"), show_col_types = FALSE) %>%
  mutate(LFM = lfm.NAs.imputed) %>% 
  filter(year == 2020) %>% 
  filter(ignition == 1) %>% 
  filter(spp == "ADFA") 

figure_epi_pca_quant.2020 <- (epi.flamdata.2020[, c("fh", "ttfg", "tti", "fd", "gd", "gti", "pfg",
         "temp.max")]) %>% 
  transmute(
    "Flame Height" = fh,
     "Max. Temp" = temp.max,
     "\n\nTime to Ignition" = tti, #space is added in front of TTI so that the labels dont overlap in the figure
     "Flame Duration" = fd,
    "\nTime to First Glow" = ttfg,
   "Glow to Ignition" = gti,
    "Glow Duration" = gd,
    "Post-flame Glow" = pfg)
  

figure_epi_pca_cat <- (epi.flamdata.2020[c("hydration", "spp", "year.month", "sample")]) %>% 
  transmute("Hydration" = hydration, 
            spp = spp,
            "Timing" = year.month, 
            "Sample" = sample) %>% 
  mutate(Species = case_when(
    spp == "ADFA" ~ "A. fasciculatum", 
    spp == "CEME" ~ "C. megacarpus"
  ))

#colnames(wine_subset)[2] <- "\nFlav"  # new line

figure_prcomp <- prcomp(na.omit(figure_epi_pca_quant.2020), center = TRUE, scale = TRUE, retx=TRUE)

#decisions for plotting:
choices = 1:2 
scale = 1
obs.scale = 1 - scale
var.scale = scale
ellipse.prob = 0.68
labels.size = 3
circle.prob = 0.69
choices = 1:2

#Run PCA
pcobj <- prcomp(na.omit(figure_epi_pca_quant.2020), center = TRUE, scale = TRUE)

# extract PCA components: 
nobs.factor <- sqrt(nrow(pcobj$x) - 1)
    d <- pcobj$sdev
    u <- sweep(pcobj$x, 2, 1/(d * nobs.factor), FUN = "*")
    v <- pcobj$rotation

  choices <- pmin(choices, ncol(u))
  df.u <- as.data.frame(sweep(u[, choices], 2, d[choices]^obs.scale, 
                              FUN = "*"))
  v <- sweep(v, 2, d^var.scale, FUN = "*")
  df.v <- as.data.frame(v[, choices])
  names(df.u) <- c("PC1", "PC2")
  names(df.v) <- names(df.u)
  df.u <- df.u * nobs.factor

  r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)
  
v.scale <- rowSums(v^2)
df.v <- r * df.v/sqrt(max(v.scale)) 
df.v <- df.v %>% mutate(PC1, PC2)
df.v$Variables <- rownames(v) 
PCAloadings = df.v
#df.v = dataset with loadings 

  #dataset with scores and categorical variables for plotting points: 
PCAvalues <- cbind(df.u, figure_epi_pca_cat)

#dataset with information for plotting circle: 
theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))

circle <- data.frame(PC1 = r * cos(theta), PC2 = r * sin(theta)) 

#Group by flam. metric: 
PCA_combustability <- df.v %>% 
  filter(Variables %in% c("Flame Height", "Max. Temp","Flame Duration"))
         
PCA_ignitability <- df.v %>% 
  filter(Variables %in% c("\n\nTime to Ignition", "\nTime to First Glow", "Glow to Ignition"))

PCA_consumability <- df.v %>% 
  filter(Variables %in% c("Glow Duration", "Post-flame Glow"))

# Calculate the angles and the label offset
df.v$Angle = ((180/pi) * atan(df.v$PC2/df.v$PC1))

df.v$Offset <- ((-2 * sign(df.v$PC1))/2)

#labels: 
u.axis.labs <- paste("PC", choices, sep = "")
u.axis.labs <- paste(u.axis.labs, sprintf("(%0.1f%% explained var.)", 
                                            100 * pcobj$sdev[choices]^2/sum(pcobj$sdev^2)))

adfa_biplot <- ggplot(PCAvalues, aes(x = PC1, y = PC2)) +
  #stat_ellipse(level = 0.95, size = 1, show.legend = FALSE) +
  geom_point(size = 1, alpha = .3, aes(shape = Species), data = PCAvalues) +
  geom_segment(data = PCA_combustability, aes(x = 0, y = 0, 
                                              xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), color = "#a56457") +
  geom_segment(data = PCA_consumability, aes(x = 0, y = 0,
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), color = "blue2") +
  geom_segment(data = PCA_ignitability, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), color = "gold1") +
  annotate("text", x = (PCA_combustability$PC1 * 1.2), y = (PCA_combustability$PC2 * 1.2), label = PCA_combustability$Variables, size = 2.6) +
  annotate("text", x = (PCA_ignitability$PC1 * 1.4), y = (PCA_ignitability$PC2 * 1.5), label = PCA_ignitability$Variables, size = 2.6) +
  annotate("text", x = (PCA_consumability$PC1 * 1.3), y = (PCA_consumability$PC2 * 1.1), label = PCA_consumability$Variables, size = 2.6) +
  th +
  scale_color_manual(values = c("blue2","#db8872")) + 
  geom_path(data = circle, color = "black",  size = 1/2, alpha = 1/3) + 
  xlab(u.axis.labs[1]) + 
   ylab(u.axis.labs[2]) +
  coord_equal()

adfa_biplot
```

##CEME
```{r warning=FALSE}
### Note: This dataset includes only Epiradiator and Ignited samples
epi.flamdata.2020 <- read_csv(here("processed-data", "compiled-datasets", "LOCAL", "mem.data.local.epi.alldates.csv"), show_col_types = FALSE) %>%
  mutate(LFM = lfm.NAs.imputed) %>% 
  filter(year == 2020) %>% 
  filter(ignition == 1) %>% 
  filter(spp == "CEME")

figure_epi_pca_quant.2020 <- (epi.flamdata.2020[, c("fh", "ttfg", "tti", "fd", "gd", "gti", "pfg",
         "temp.max")]) %>% 
  transmute(
    "Flame Height" = fh,
     "Max. Temp" = temp.max,
     "\n\nTime to Ignition" = tti, #space is added in front of TTI so that the labels dont overlap in the figure
     "Flame Duration" = fd,
    "\nTime to First Glow" = ttfg,
   "Glow to Ignition" = gti,
    "Glow Duration" = gd,
    "Post-flame Glow" = pfg)
  

figure_epi_pca_cat <- (epi.flamdata.2020[c("hydration", "spp", "year.month", "sample")]) %>% 
  transmute("Hydration" = hydration, 
            spp = spp,
            "Timing" = year.month, 
            "Sample" = sample) %>% 
  mutate(Species = case_when(
    spp == "ADFA" ~ "A. fasciculatum", 
    spp == "CEME" ~ "C. megacarpus"
  ))

#colnames(wine_subset)[2] <- "\nFlav"  # new line

figure_prcomp <- prcomp(na.omit(figure_epi_pca_quant.2020), center = TRUE, scale = TRUE, retx=TRUE)
```

Setting up plotting data: 

```{r}
#decisions for plotting:
choices = 1:2 
scale = 1
obs.scale = 1 - scale
var.scale = scale
ellipse.prob = 0.68
labels.size = 3
circle.prob = 0.69
choices = 1:2

#Run PCA
pcobj <- prcomp(na.omit(figure_epi_pca_quant.2020), center = TRUE, scale = TRUE)

# extract PCA components: 
nobs.factor <- sqrt(nrow(pcobj$x) - 1)
    d <- pcobj$sdev
    u <- sweep(pcobj$x, 2, 1/(d * nobs.factor), FUN = "*")
    v <- pcobj$rotation

  choices <- pmin(choices, ncol(u))
  df.u <- as.data.frame(sweep(u[, choices], 2, d[choices]^obs.scale, 
                              FUN = "*"))
  v <- sweep(v, 2, d^var.scale, FUN = "*")
  df.v <- as.data.frame(v[, choices])
  names(df.u) <- c("PC1", "PC2")
  names(df.v) <- names(df.u)
  df.u <- df.u * nobs.factor

  r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)
  
v.scale <- rowSums(v^2)
df.v <- r * df.v/sqrt(max(v.scale)) 
df.v <- df.v %>% mutate(PC1, PC2)
df.v$Variables <- rownames(v) 
PCAloadings = df.v
#df.v = dataset with loadings 

  #dataset with scores and categorical variables for plotting points: 
PCAvalues <- cbind(df.u, figure_epi_pca_cat)

#dataset with information for plotting circle: 
theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))

circle <- data.frame(PC1 = r * cos(theta), PC2 = r * sin(theta)) 

#Group by flam. metric: 
PCA_combustability <- df.v %>% 
  filter(Variables %in% c("Flame Height", "Max. Temp","Flame Duration"))
         
PCA_ignitability <- df.v %>% 
  filter(Variables %in% c("\n\nTime to Ignition", "\nTime to First Glow", "Glow to Ignition"))

PCA_consumability <- df.v %>% 
  filter(Variables %in% c("Glow Duration", "Post-flame Glow"))

# Calculate the angles and the label offset
df.v$Angle = ((180/pi) * atan(df.v$PC2/df.v$PC1))

df.v$Offset <- ((-2 * sign(df.v$PC1))/2)

#labels: 
u.axis.labs <- paste("PC", choices, sep = "")
u.axis.labs <- paste(u.axis.labs, sprintf("(%0.1f%% explained var.)", 
                                            100 * pcobj$sdev[choices]^2/sum(pcobj$sdev^2)))

# Plot
ceme_biplot <- ggplot(PCAvalues, aes(x = PC1, y = PC2)) +
  #stat_ellipse(level = 0.95, size = 1, show.legend = FALSE) +
  geom_point(size = 1, alpha = .3, aes(shape = Species), data = PCAvalues) +
  geom_segment(data = PCA_combustability, aes(x = 0, y = 0, 
                                              xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), color = "#a56457") +
  geom_segment(data = PCA_consumability, aes(x = 0, y = 0,
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), color = "blue2") +
  geom_segment(data = PCA_ignitability, aes(x = 0, y = 0, 
                                             xend = PC1, yend = PC2),
     arrow = arrow(length = unit(1/2, "picas")), color = "gold1") +
  annotate("text", x = (PCA_combustability$PC1 * 1.2), y = (PCA_combustability$PC2 * 1.2), label = PCA_combustability$Variables, size = 2.6) +
  annotate("text", x = (PCA_ignitability$PC1 * 1.4), y = (PCA_ignitability$PC2 * 1.5), label = PCA_ignitability$Variables, size = 2.6) +
  annotate("text", x = (PCA_consumability$PC1 * 1.3), y = (PCA_consumability$PC2 * 1.1), label = PCA_consumability$Variables, size = 2.6) +
  th +
  scale_color_manual(values = c("blue2","#db8872")) + 
  geom_path(data = circle, color = "black",  size = 1/2, alpha = 1/3) + 
  xlab(u.axis.labs[1]) + 
   ylab(u.axis.labs[2]) +
  coord_equal()

ceme_biplot
```

#------------------------------------
# 2. Data wrangling

###All dates datasets
```{r, message=FALSE, warning=FALSE, include=FALSE}
mem.data.alldates <- read_csv(here("processed-data", "compiled-datasets", "LOCAL", "mem.data.local.epi.alldates.csv"), show_col_types = FALSE)

mem.data.raw.alldates <- mem.data.alldates %>%
  mutate(mpa = case_when(
    mpa > 0 ~ (-1*mpa), 
    mpa < 0 ~ mpa)) %>% 
  mutate(year = as.factor(year)) %>%
  mutate(month = as.factor(month)) %>% 
  mutate(mpa.unscaled = mpa) %>% 
  mutate(lfm.unscaled = lfm)%>% 
  mutate(lfm.NAs.imputed.unscaled = lfm.NAs.imputed) %>% 
  mutate(excess_water = ww.flam.sample - dw.flam.sample) %>% 
  mutate(excess_water.unscaled = excess_water)
 # mutate(lfm = lfm.NAs.imputed)

clean.mem.data.alldates <- mem.data.raw.alldates
  #na.omit() %>%
  #filter(year.month == "2020_September")

#Parsing out the variables of interest for the mixed effects modelling

clean.mem.data.dependant.alldates <- clean.mem.data.alldates[,c('PC1', 'PC2', 'PC3', 'PC4', 'tti', 'fh', 'gd', 'temp.max', 'flam.index', 'year', 'month', 'prop.ignite', 'prop.ignite.bins5', "ignition")] 
 
scaled.mem.data.predictors.alldates.adfa <- clean.mem.data.alldates %>%
  filter(spp == "ADFA") %>% 
  dplyr::select('lfm.NAs.imputed', 'lfm.outliers.out', 'mpa', 'dw.flam.sample', 'sample.wt', 'ww.flam.sample', 'gww.gdw.saturated', 'gdw.gww.saturated', 'lfm', 'excess_water') %>%
 scale()
  
scaled.mem.data.predictors.alldates.ceme <- clean.mem.data.alldates %>%
  filter(spp == "CEME") %>% 
  dplyr::select('lfm.NAs.imputed', 'lfm.outliers.out', 'mpa', 'dw.flam.sample', 'sample.wt', 'ww.flam.sample', 'gww.gdw.saturated', 'gdw.gww.saturated', 'lfm', 'excess_water') %>%
 scale()
  
scaled.mem.data.predictors.alldates <- rbind(scaled.mem.data.predictors.alldates.adfa, scaled.mem.data.predictors.alldates.ceme)

mem.data.predictors.alldates <- clean.mem.data.alldates %>%
    dplyr::select('spp', 'year.month', 'individual', 'site', 'start.temp', 'precip.2mo','mpa.unscaled', 'lfm.unscaled', 'lfm.NAs.imputed.unscaled', 'excess_water.unscaled') 

scaled.mem.data.alldates <- cbind(scaled.mem.data.predictors.alldates, 
                         mem.data.predictors.alldates,
                         clean.mem.data.dependant.alldates) 

#For sept. 2020 only: 
scaled.mem.data.alldates <- scaled.mem.data.alldates %>% 
  mutate(Species = case_when(
    spp == "ADFA" ~ "A. fasciculatum", 
    spp == "CEME" ~ "C. megacarpus"
  )) 

scaled.mem.data.alldates.noNAs <- scaled.mem.data.alldates %>% 
  drop_na(mpa, lfm, PC1)

seg.data.subset.alldates <- scaled.mem.data.alldates.noNAs %>% 
  mutate(id = individual) 
#%>% 
 #dplyr::select(id, PC1, PC2, mpa, lfm, ww.flam.sample, dw.flam.sample, spp, tti, mpa.unscaled, prop.ignite, prop.ignite.bins5, fh, gd) 

seg.data.subset.alldates<-seg.data.subset.alldates[order(seg.data.subset.alldates$id),]
```

```{r}
predictors.alldates <- scaled.mem.data.alldates.noNAs %>% 
  mutate(lfm.scaled = lfm.NAs.imputed) %>% 
  mutate(mpa.scaled = mpa) %>% 
  select(lfm.unscaled, lfm.scaled, mpa.unscaled, 
         mpa.scaled, dw.flam.sample,
         ww.flam.sample, excess_water, spp)

ggpairs(predictors.alldates, aes(color = spp,  # Color by group (cat. variable)
            alpha = 0.3))
```

###2020 datasets

Wrangled in: 1_data_wrangling_local_shortened.Rmd

Note: lfm.NAs.imputed via: 
    impute_rlm(lfm.NAs.imputed ~ mpa + dry.wt + fresh.wt | year.month.spp)
    Not many values ultimately imputed
    
```{r, message=FALSE, warning=FALSE, include=FALSE}
mem.data.2020 <- read_csv(here("processed-data", "compiled-datasets", "LOCAL", "mem.data.local.epi.2020.csv"), show_col_types = FALSE)


mem.data.raw.2020 <- mem.data.2020 %>%
  mutate(mpa = case_when(
    mpa > 0 ~ (-1*mpa), 
    mpa < 0 ~ mpa)) %>% 
  mutate(year = as.factor(year)) %>%
  mutate(month = as.factor(month)) %>% 
  mutate(mpa.unscaled = mpa) %>% 
  mutate(lfm.unscaled = lfm) %>% 
  mutate(lfm.NAs.imputed.unscaled = lfm.NAs.imputed)%>% 
  mutate(lfm.unscaled = lfm) %>% 
  mutate(excess_water.unscaled = ww.flam.sample - dw.flam.sample) %>% 
  mutate(excess_water.scaled = excess_water.unscaled) 
 # mutate(lfm = lfm.NAs.imputed)

clean.mem.data.2020 <- mem.data.raw.2020
  #filter(year.month == "2020_September")

#Parsing out the variables of interest for the mixed effects modelling

#dont scale these:
clean.mem.data.dependant.2020 <- clean.mem.data.2020[,c('PC1', 'PC2', 'PC3', 'PC4', 'tti', 'fh', 'gd', "fd", 'temp.max', 'flam.index', 'year', 'month', 'prop.ignite', 'prop.ignite.bins5', "ignition")] 
  
#scale these: 
scaled.mem.data.predictors.2020.ceme <- clean.mem.data.2020 %>%
    filter(spp == "CEME") %>% 
  dplyr::select('lfm.NAs.imputed', 'lfm.outliers.out', 'mpa', 'dw.flam.sample', 'sample.wt', 'ww.flam.sample', 'gww.gdw.saturated', 'gdw.gww.saturated', 'lfm', 'excess_water.scaled') %>%
 scale()

scaled.mem.data.predictors.2020.adfa <- clean.mem.data.2020 %>%
    filter(spp == "ADFA") %>% 
  dplyr::select('lfm.NAs.imputed', 'lfm.outliers.out', 'mpa', 'dw.flam.sample', 'sample.wt', 'ww.flam.sample', 'gww.gdw.saturated', 'gdw.gww.saturated', 'lfm', 'excess_water.scaled') %>%
 scale()

scaled.mem.data.predictors.2020 <- rbind(scaled.mem.data.predictors.2020.adfa, scaled.mem.data.predictors.2020.ceme)

#dont scale these: 
mem.data.predictors.2020 <- clean.mem.data.2020 %>%
    dplyr::select('spp', 'year.month', 'individual', 'site', 'start.temp', 'precip.2mo','mpa.unscaled', 'lfm.unscaled', 'lfm.NAs.imputed.unscaled', "excess_water.unscaled") 

scaled.mem.data.2020 <- cbind(scaled.mem.data.predictors.2020, 
                         mem.data.predictors.2020,
                         clean.mem.data.dependant.2020) %>% 
  mutate(Species = case_when(
    spp == "ADFA" ~ "A. fasciculatum", 
    spp == "CEME" ~ "C. megacarpus"
  ))  %>% 
  mutate(id = individual) 

####Dropping NAs

scaled.mem.data.2020.noNAs <- scaled.mem.data.2020 %>% 
  drop_na(lfm, mpa)

seg.data.subset.2020<-scaled.mem.data.2020.noNAs[order(scaled.mem.data.2020.noNAs$id),]
```

```{r}
predictors <- scaled.mem.data.2020.noNAs %>% 
  mutate(lfm.scaled = lfm.NAs.imputed) %>% 
  mutate(mpa.scaled = mpa) %>% 
  select(lfm.unscaled, lfm.scaled, mpa.unscaled, 
         mpa.scaled, dw.flam.sample,
         ww.flam.sample, excess_water.scaled, 
         excess_water.unscaled, spp)

ggpairs(predictors, aes(color = spp,  # Color by group (cat. variable)
            alpha = 0.3))
```

These have no NAs: 

```{r, message=FALSE, warning=FALSE, include=FALSE}
seg.adfa.subset <- seg.data.subset.2020  %>% 
  filter(spp == "ADFA") %>% 
  filter(ignition == "1")

seg.CEME.subset <- seg.data.subset.2020  %>% 
  filter(spp == "CEME")%>% 
  filter(ignition == "1")

seg.adfa.subset.allignitions <- seg.data.subset.2020  %>% 
  filter(spp == "ADFA")

seg.ceme.subset.allignitions <- seg.data.subset.2020  %>% 
  filter(spp == "CEME")
```

#------------------------------------
#2.1 Model Figures
#### 2.1.1 Figure of model 

###### Water Potential vs. PC1

```{r}
mpa_mod_fig.mpa <- lmer(PC1 ~ mpa.unscaled + Species + (1 | individual), data = scaled.mem.data.2020.noNAs)
```


####Species differences: 

```{r}
#adfa
mpa_mod_fig_adfa <- lmer(PC1 ~ mpa.unscaled + (1 | individual), data = seg.adfa.subset)

effects_mpa_fig_adfa <- effects::effect(term= "mpa.unscaled", 
                                   mod= mpa_mod_fig_adfa, 
                                   se = TRUE, 
                                   confidence.level=.95)
# Save the effects values as a df:
x_mpa_fig_adfa <- as.data.frame(effects_mpa_fig_adfa)

#ceme
mpa_mod_fig_ceme <- lmer(PC1 ~ mpa.unscaled + (1 | individual), data = seg.CEME.subset)

effects_mpa_fig_ceme <- effects::effect(term= "mpa.unscaled", 
                                   mod= mpa_mod_fig_ceme, 
                                   se = TRUE, 
                                   confidence.level=.95)
# Save the effects values as a df:
x_mpa_fig_ceme <- as.data.frame(effects_mpa_fig_ceme)

# Separating by Species 
p <- ggplot() + 
  geom_point(data= scaled.mem.data.2020, 
            aes(mpa.unscaled, PC1, 
            color = Species, 
            shape = Species
             ), 
            size = 1
             ) +
  #scale_shape_manual(values = c(1, 21)) + 
  #geom_point(data=x_mpa_fig, aes(x=mpa.unscaled, y=fit), color="#7570b3", size = 1) +
  geom_line(data=x_mpa_fig_adfa, aes(x=mpa.unscaled, 
                                     y=fit, 
                                     color = Species), 
            color="gold1") +
  geom_line(data=x_mpa_fig_ceme, aes(
    x=mpa.unscaled,
    y=fit, 
    color = Species), 
    color="blue2") +
  geom_ribbon(data= x_mpa_fig_adfa, aes(x=mpa.unscaled, ymin=lower, ymax=upper), alpha= 0.3, fill="gold1") +
  geom_ribbon(data= x_mpa_fig_ceme, aes(x=mpa.unscaled, ymin=lower, ymax=upper), alpha= 0.3, fill="blue2") +
  labs(x="Water Potential (-Mpa)", 
       y="PC1", 
       color = "", 
       shape = "") +
  scale_color_manual(values = c("blue2", "gold1")) +
  #scale_color_manual(values = c("blue", "yellow")) +
  th 


p +
  annotate("segment", x = -11, 
           xend = -11, y = -3, 
           yend = 3,
           linejoin = 'mitre',
           #colour = "#db8872", 
           colour = "black", 
           size = 1, 
           arrow = arrow(ends = "last", 
                                 angle = 33, 
                                  #type = "closed", 
                                  length = unit(.2,"cm"))) +
 # annotate("segment", x = -9, xend = -1, y = -4, yend = -4,
          # colour = "#7570b3", size = .7, arrow = arrow(ends = "last", angle = 25, type = "closed", length = unit(.2,"cm")))  +
  annotate("text", x= -11, y= 4, label= "Shorter TTI", size = 3) +
  annotate("text", x= -11, y= 3.5, label= "Higher FH", size = 3) +
annotate("text", x= -11, y= -3.5, label= "Higher TTI", size = 3) +
  annotate("text", x= -11, y= -4, label= "Smaller FH", size = 3)  +
  th +
  scale_x_continuous(limits = c(-11.5, 0), breaks= c(-10, -8, -6, -4, -2, 0)) + 
  theme(
    legend.position = c(.83, .93),
   # legend.position = "bottom", 
    legend.box = "vertical", 
    #legend.justification = c("right", "top"),
    #legend.box.just = "bottom",
    legend.margin = margin(2,2,2,2), 
    legend.key = element_rect(fill = "white", 
                              color = "black",
                              linetype = "solid"),
    legend.background = element_rect(fill = NA, 
                                     #color = "black", 
                                     #linetype = "solid"
                                     )
    ) +
  theme(strip.text = element_text(face = "italic"), 
        axis.title = element_text(face = "bold"),
        legend.title = element_text(face = "bold"), 
        legend.text = element_text(face = "italic")) +
  th
```

```{r}
#fit the model
mpa_mod_fig.mpa <- lmer(PC1 ~ mpa + Species + (Species | individual), data = scaled.mem.data.2020)

#the next line put all the estimated intercept and slope per
#individual into a dataframe
PC1 <- as.data.frame(t(apply(ranef(mpa_mod_fig.mpa)$individual,
  1,function(x) fixef(mpa_mod_fig.mpa) + x)))
#to get the predicted regression lines we need one further
#step, writing the linear equation: Intercept + Slope*Species
#with different coefficient for each individual
pred_slp <- melt(apply(PC1,1,function(x) x[1] + x[2]*-2:2),
  value.name = "PC1")
#some re-formatting for the plot
names(pred_slp)[1:2] <- c("mpa", "individual")
pred_slp$mpa <- pred_slp$mpa
pred_slp$individual <- as.factor(pred_slp$individual)

#plot with actual data
ggplot(pred_slp, aes(x=mpa,y=PC1,color=individual)) +
  geom_line()+
  geom_point(data=scaled.mem.data.2020,aes(x=mpa,y=PC1))+
  facet_wrap(~individual,nrow=3) +
  theme(legend.position = "none")
```

## Predicted vs. Observed PC1
```{r}
# predicted_pc1_df <- data.frame(predicted_pc1 = predict(mpa_mod_fig.mpa), observed_pc1 = scaled.mem.data.2020$PC1)
# 
# ggplot(data = predicted_pc1_df, aes(x = predicted_pc1, y = observed_pc1)) +
#   geom_point(color = "#db8872", size = .7) +
#   geom_abline() +
#   labs(title = "Predicted vs. Observed PC1", 
#        subtitle = "All dates, mpa model",
#        x = "Predicted PC1", 
#        y = "Observed PC1") +
#   th +
#   ylim(-3, 3) +
#   xlim(-3, 3) +
#   coord_equal()
```

```{r}
effects_mpa_fig.mpa <- effects::effect(term= "mpa.unscaled", 
                                   mod= mpa_mod_fig_adfa, 
                                   se = TRUE, 
                                   confidence.level=.95)
# Save the effects values as a df:
x_mpa_fig.mpa <- as.data.frame(effects_mpa_fig.mpa)
```

**Figure X.** Model estimate of flammability (principle component 1) from water potential. 

```{r, message=FALSE, results='hide',fig.height= 2, fig.length = 4}
# Separating by Species
p <- ggplot() + 
  geom_point(data= scaled.mem.data.2020, aes(mpa.unscaled, PC1, color = Species), size = .5) + 
  #geom_point(data=x_mpa_fig, aes(x=mpa.unscaled, y=fit), color="#7570b3", size = 1) +
  geom_line(data=x_mpa_fig.mpa, aes(x=mpa.unscaled, y=fit), color="#db8872") +
  geom_ribbon(data= x_mpa_fig.mpa, aes(x=mpa.unscaled, ymin=lower, ymax=upper), alpha= 0.3, fill="#db8872") +
  labs(x="Water Potential (-Mpa)", y="Principle Component 1") +
 # scale_color_manual(values = c("blue2", "gold1")) +
  scale_color_manual(values = c("blue2", "gold1"))
  th 

p +
  annotate("segment", x = -11, xend = -11, y = -3, yend = 3,
           colour = "#db8872", size = .7, arrow = arrow(ends = "last", angle = 25, type = "closed", length = unit(.2,"cm"))) +
 # annotate("segment", x = -9, xend = -1, y = -4, yend = -4,
          # colour = "#7570b3", size = .7, arrow = arrow(ends = "last", angle = 25, type = "closed", length = unit(.2,"cm")))  +
  annotate("text", x= -11, y= 4, label= "More", size = 3) +
  annotate("text", x= -11, y= 3.5, label= "Flammable", size = 3)+
annotate("text", x= -11, y= -3.5, label= "Less", size = 3) +
  annotate("text", x= -11, y= -4, label= "Flammable", size = 3)  +
  th +
  scale_x_continuous(limits = c(-11.5, 0), breaks= c(-10, -8, -6, -4, -2, 0)) + 
  theme(
    legend.position = c(.99, .99),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.margin = margin(4,4,4,4)
    ) 
```
######Water Potential vs. TTI

```{r}
mpa_mod_fig <- lmer(tti ~ mpa.unscaled + Species + (1 | individual), data = scaled.mem.data.2020)

effects_mpa_fig <- effects::effect(term= "mpa.unscaled", 
                                   mod= mpa_mod_fig, 
                                   se = TRUE, 
                                   confidence.level=.95)
# Save the effects values as a df:
x_mpa_fig <- as.data.frame(effects_mpa_fig)

# Separating by Species
p <- ggplot() + 
  geom_point(data= scaled.mem.data.2020, aes(mpa.unscaled, tti, color = Species), size = .5) + 
  #geom_point(data=x_mpa_fig, aes(x=mpa.unscaled, y=fit), color="#7570b3", size = 1) +
  geom_line(data=x_mpa_fig, aes(x=mpa.unscaled, y=fit), color="#7570b3") +
  geom_ribbon(data= x_mpa_fig, aes(x=mpa.unscaled, ymin=lower, ymax=upper), alpha= 0.3, fill="#7570b3") +
  labs(x="Water Potential (-Mpa)", 
       y="Time to Ignition (sec)") +
  scale_color_manual(values = c("blue2", "gold1")) +
  th 


p +
  annotate("segment", x = -11, xend = -11, y = 20, yend = 60,
           colour = "#7570b3", size = .7, arrow = arrow(ends = "last", angle = 25, type = "closed", length = unit(.2,"cm"))) +
 # annotate("segment", x = -9, xend = -1, y = -4, yend = -4,
          # colour = "#7570b3", size = .7, arrow = arrow(ends = "last", angle = 25, type = "closed", length = unit(.2,"cm")))  +
  annotate("text", x= -11, y= 70, label= "More", size = 3) +
  annotate("text", x= -11, y= 65, label= "Flammable", size = 3)+
annotate("text", x= -11, y= 15, label= "Less", size = 3) +
  annotate("text", x= -11, y= 10, label= "Flammable", size = 3) +
  th +
  scale_x_continuous(limits = c(-12, 0), breaks= c(-10, -8, -6, -4, -2, 0))
```

#### Species differences: 

```{r}
#adfa
mpa_mod_fig_adfa <- lmer(tti ~ mpa.unscaled + (1 | individual), data = seg.adfa.subset)

effects_mpa_fig_adfa <- effects::effect(term= "mpa.unscaled", 
                                   mod= mpa_mod_fig_adfa, 
                                   se = TRUE, 
                                   confidence.level=.95)
# Save the effects values as a df:
x_mpa_fig_adfa <- as.data.frame(effects_mpa_fig_adfa)

#ceme
mpa_mod_fig_ceme <- lmer(tti ~ mpa.unscaled + (1 | individual), data = seg.CEME.subset)

effects_mpa_fig_ceme <- effects::effect(term= "mpa.unscaled", 
                                   mod= mpa_mod_fig_ceme, 
                                   se = TRUE, 
                                   confidence.level=.95)
# Save the effects values as a df:
x_mpa_fig_ceme <- as.data.frame(effects_mpa_fig_ceme)

# Separating by Species
p <- ggplot() + 
  geom_point(data= scaled.mem.data.2020, aes(mpa.unscaled, tti, color = Species), size = .5) + 
  #geom_point(data=x_mpa_fig, aes(x=mpa.unscaled, y=fit), color="#7570b3", size = 1) +
  geom_line(data=x_mpa_fig_adfa, aes(x=mpa.unscaled, y=fit), color = "#7c668c" ) +
  geom_line(data=x_mpa_fig_ceme, aes(x=mpa.unscaled, y=fit), color = "blue2") +
  geom_ribbon(data= x_mpa_fig_adfa, aes(x=mpa.unscaled, ymin=lower, ymax=upper), alpha= 0.3, fill = "#7c668c" ) +
  geom_ribbon(data= x_mpa_fig_ceme, aes(x=mpa.unscaled, ymin=lower, ymax=upper), alpha= 0.3, fill = "blue2") +
  labs(x="Water Potential (-Mpa)", 
       y="Time to Ignition (sec)")  +
  scale_color_manual(values=met.brewer("Morgenstern", 7)) +
  th 
p

p +
  #annotate("segment", x = -11, xend = -11, y = 20, yend = 60,
         #  colour = "#a56457", size = 1, arrow = arrow(ends = "last", angle = 25, type = "closed", length = unit(.2,"cm"))) +
 # annotate("segment", x = -9, xend = -1, y = -4, yend = -4,
          # colour = "#7570b3", size = .7, arrow = arrow(ends = "last", angle = 25, type = "closed", length = unit(.2,"cm")))  +
  #annotate("text", x= -11, y= 70, label= "More", size = 3) +
  #annotate("text", x= -11, y= 65, label= "Flammable", size = 3)+
   #annotate("text", x= -11, y= 15, label= "Less", size = 3) +
  #annotate("text", x= -11, y= 10, label= "Flammable", size = 3) +
  th +
  scale_x_continuous(limits = c(-10, 0), breaks= c(-10, -8, -6, -4, -2, 0)) +
  theme(legend.position = "bottom")
```

```{r}
scaled.mem.data.2020.noNAs %>% 
  ggplot(aes(y = PC1, x = mpa, color = spp)) +
  geom_point() +
  geom_smooth(method = "lm") +
  xlim(-1.5, 0)
```
```{r}
scaled.mem.data.2020.noNAs %>% 
  ggplot(aes(y = PC1, x = mpa.unscaled, color = spp)) +
  geom_point() +
  geom_smooth(method = "lm") +
  xlim(-10, 0)
```

```{r}
scaled.mem.data.2020.noNAs %>% 
  ggplot(aes(y = PC1, x = mpa, color = spp)) +
  geom_point() +
  geom_smooth(method = "lm")
```

#### *****2.1.2 Table of models

"The variance inflation factor is a measure to analyze the magnitude of multicollinearity of model terms. A VIF less than 5 indicates a low correlation of that predictor with other predictors. A value between 5 and 10 indicates a moderate correlation, while VIF values larger than 10 are a sign for high, not tolerable correlation of model predictors.

The Increased SE column in the output indicates how much larger the standard error is due to the correlation with other predictors." (https://easystats.github.io/blog/posts/performance_check_collinearity/)

```{r}
mpa_mod_fig.mpa <- lmer(PC1 ~ mpa + spp + site +(1 | individual), data = scaled.mem.data.2020.noNAs)

mpa_mod_fig.mpa
performance::multicollinearity(mpa_mod_fig.mpa)

scaled.mem.data.2020.noNAs %>% 
  ggplot(aes(y = PC1, x = mpa)) +
  geom_point()+
  geom_smooth()
```


```{r}
max_model <- lmer(PC1 ~ spp + dw.flam.sample + ww.flam.sample + mpa + lfm.NAs.imputed + excess_water.scaled + (1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(max_model)
```

```{r}
max_model_mpaunscaled <- lmer(PC1 ~ spp + dw.flam.sample + ww.flam.sample + mpa.unscaled + lfm.unscaled + excess_water.scaled + site + (1 | individual), data = scaled.mem.data.2020.noNAs)

max_model_mpaunscaled

performance::multicollinearity(max_model)
```


```{r}
max_nocorr_model_mpaunscaled <- lmer(PC1 ~ spp + mpa + lfm.NAs.imputed + site + (1 | individual), data = scaled.mem.data.2020.noNAs)

max_nocorr_model_mpaunscaled
summary(max_nocorr_model_mpaunscaled)
performance::multicollinearity(max_nocorr_model_mpaunscaled)
```

```{r}
max_nocorr_model_mpaunscaled <- lmer(PC1 ~ spp + mpa.unscaled + lfm.unscaled + site + (1 | individual), data = scaled.mem.data.2020.noNAs)

max_nocorr_model_mpaunscaled
summary(max_nocorr_model_mpaunscaled)
performance::multicollinearity(max_nocorr_model_mpaunscaled)
```

```{r}
max_model_nolfm_mpaunscaled <- lmer(PC1 ~ spp + dw.flam.sample + ww.flam.sample + mpa.unscaled + site +(1 | individual), data = scaled.mem.data.2020.noNAs)

summary(max_model_nolfm_mpaunscaled)

performance::multicollinearity(max_model_nolfm_mpaunscaled)
```

```{r}
max_model_nolfm <- lmer(PC1 ~ spp + dw.flam.sample + ww.flam.sample + mpa + excess_water.scaled + site +(1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(max_model_nolfm)
```

```{r}
max_model_nompa <- lmer(PC1 ~ spp + dw.flam.sample + ww.flam.sample + lfm.NAs.imputed + excess_water.scaled + site + (1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(max_model_nompa)
```

```{r}
m3 <- lmer(PC1 ~ spp + ww.flam.sample + site +(1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(m3)
```


```{r}
m6 <- lmer(PC1 ~ dw.flam.sample + spp +site + (1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(m6)
```


```{r}
m6.5 <- lmer(PC1 ~ dw.flam.sample + ww.flam.sample + spp + site +(1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(m6.5)
```


```{r}
m7 <- lmer(PC1 ~ mpa + lfm.NAs.imputed + spp + site +(1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(m7)
```


```{r}
m10 <- lmer(PC1 ~ lfm.NAs.imputed + spp + site +(1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(m10)
```


```{r}
m11 <- lmer(PC1 ~ mpa*spp + site +(1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(m11)
```


```{r}
m12 <- lmer(PC1 ~ excess_water.scaled + spp + site +(1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(m12)
```


```{r}
m12.5 <- lmer(PC1 ~ excess_water.scaled + mpa + lfm.NAs.imputed + spp + site +(1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(m12.5) ##High correlation! Don't use

```


```{r}
m13 <- lmer(PC1 ~ excess_water.scaled + lfm.NAs.imputed + spp + site + (1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(m13) ##High correlation! Don't use
```


```{r}
m14 <- lmer(PC1 ~ excess_water.scaled + spp + site +(1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(m14)
```


```{r}
m15 <- lmer(PC1 ~ excess_water.scaled * spp + site +(1 | individual), data = scaled.mem.data.2020.noNAs)

performance::multicollinearity(m15)
```

```{r}
# models <- list(top_model, m7, m10, m3, m6)
# 
# # build table with `modelsummary` 
# cm <- c( '(Intercept)' = 'Intercept', 
#          'mpa' = 'Water Potential (-Mpa)', 
#          'lfm.NAs.imputed' = 'LFM (%)',
#          'ww.flam.sample' = 'Water weight (g)', 
#          'dw.flam.sample' = 'Dry weight (g)', 
#          'sppCEME' = 'C. megacarpus')
# cap <- 'Candidate models for predicting flammability (PC1)'
# 
# 
# modelsummary <- modelsummary(models,
#                              statistic = "p = {p.value}",
#                              stars = TRUE, 
#                              coef_map = cm, 
#                              title = cap, 
#                              output = 'flextable') %>% 
#   flextable::autofit()
# modelsummary
```

https://strengejacke.github.io/sjPlot/articles/tab_model_estimates.html 

```{r}
#tab_model(top_model, m7, m10, m3, m6) 
tab_model(mpa_mod_fig.mpa, m11, m7, m10, m3, m6, m6.5, m12, m15,
          show.reflvl = TRUE, 
          digits = 3, 
          show.aic = TRUE, 
          show.ci = FALSE,
          show.icc = FALSE, 
          pred.labels = c('Intercept', 
                          'Water Potential (-Mpa)', 
                          'C. megacarpus',
                           'LFM (%)',
                          'Water weight (g)', 
                          'Dry weight (g)'), 
         dv.labels = c("mppa_spp", 
                       "m11", 
                       "m7", 
                       "m7",
                       "m10",
                       "m3", 
                       "m6", 
                       "m6.5", 
                       "m12",
                       "m15"),
         string.pred = "Coeffcient", 
         title = "models with no collinearity",
  string.p = "P-Value", 
  p.style = "stars")
```
```{r}
#tab_model(top_model, m7, m10, m3, m6) 
tab_model(max_model, m7, mpa_mod_fig.mpa, max_model_nolfm, max_model_nompa, m12.5, m13,
          show.reflvl = TRUE, 
          digits = 3, 
          show.aic = TRUE, 
          show.ci = FALSE,
          show.icc = FALSE, 
          pred.labels = c('Intercept', 
                          'Water Potential (-Mpa)', 
                          'C. megacarpus',
                           'LFM (%)',
                          'Water weight (g)', 
                          'Dry weight (g)'), 
         dv.labels = c("max_model", 
                       "m7**", 
                       "mpa_spp**", 
                       "max_model_nolfm", 
                      "max_model_nompa", 
                      "m12.5", 
                      "m13"),
         string.pred = "Coeffcient", 
         title = "models WITH collinearity (except **)",
  string.p = "P-Value", 
  p.style = "stars")
```
The intra-class correlation coefficient (ICC) is a related statistic that quantifies the proportion of variance explained by a grouping (random) factor in multilevel/hierarchical data.

#------------------------------------
#2.2. Raw values

Flame height models: 
```{r}
mpa_mod_fig.mpa <- lmer(fh ~ mpa + spp + (1 | individual), data = scaled.mem.data.2020.noNAs)

m1 <- lmer(fh ~ mpa + spp + excess_water.scaled + lfm + (1 | individual), data = scaled.mem.data.2020.noNAs)

m3 <- lmer(fh ~ spp + ww.flam.sample + (1 | individual), data = scaled.mem.data.2020.noNAs)
  
m6 <- lmer(fh ~ dw.flam.sample + spp + (1 | individual), data = scaled.mem.data.2020.noNAs)

m7 <- lmer(fh ~ mpa + lfm + spp + (1 | individual), data = scaled.mem.data.2020.noNAs)
m7

m10 <- lmer(fh ~ lfm + spp + (1 | individual), data = scaled.mem.data.2020.noNAs)

m11 <- lmer(fh ~ mpa*spp + (1 | individual), data = scaled.mem.data.2020.noNAs)

#tab_model(top_model, m7, m10, m3, m6) 
tab_model(mpa_mod_fig.mpa,m1,  m11, m7, m10, m3, m6, 
          show.reflvl = TRUE, 
          digits = 3, 
          show.aic = TRUE, 
          show.ci = FALSE,
          show.icc = FALSE, 
          pred.labels = c('Intercept', 
                          'Water Potential (-Mpa)', 
                          'C. megacarpus',
                           'LFM (%)',
                          'Water weight (g)', 
                          'Dry weight (g)'), 
         dv.labels = c("Model 1", 
                       "Model 2", 
                       "Model 3", 
                       "Model 4", 
                       "Model 5", 
                       "Model 6"),
         string.pred = "Coeffcient",
  string.p = "P-Value", 
  p.style = "stars")
```
Temp max models:
```{r}
mpa_mod_fig.mpa <- lmer(temp.max ~ mpa + spp + (1 | individual), data = scaled.mem.data.2020.noNAs)

m3 <- lmer(temp.max ~ spp + ww.flam.sample + (1 | individual), data = scaled.mem.data.2020.noNAs)
  
m6 <- lmer(temp.max ~ dw.flam.sample + spp + (1 | individual), data = scaled.mem.data.2020.noNAs)

m7 <- lmer(temp.max ~ mpa + lfm + spp + (1 | individual), data = scaled.mem.data.2020.noNAs)
m7

m10 <- lmer(temp.max ~ lfm + spp + (1 | individual), data = scaled.mem.data.2020.noNAs)

m11 <- lmer(temp.max ~ spp + (1 | individual), data = scaled.mem.data.2020.noNAs)

#tab_model(top_model, m7, m10, m3, m6) 
tab_model(mpa_mod_fig.mpa, m11, m7, m10, m3, m6, 
          show.reflvl = TRUE, 
          digits = 3, 
          show.aic = TRUE, 
          show.ci = FALSE,
          show.icc = FALSE, 
          pred.labels = c('Intercept', 
                          'Water Potential (-Mpa)', 
                          'C. megacarpus',
                           'LFM (%)',
                          'Water weight (g)', 
                          'Dry weight (g)'), 
         dv.labels = c("Model 1", 
                       "Model 2", 
                       "Model 3", 
                       "Model 4", 
                       "Model 5", 
                       "Model 6"),
         string.pred = "Coeffcient",
  string.p = "P-Value", 
  p.style = "stars")
```

Flame duration models: 
```{r}
mpa_mod_fig.mpa <- lmer(fd ~ mpa + spp + (1 | individual), data = scaled.mem.data.2020.noNAs)

m3 <- lmer(fd ~ spp + ww.flam.sample + (1 | individual), data = scaled.mem.data.2020.noNAs)
  
m6 <- lmer(fd ~ dw.flam.sample + spp + (1 | individual), data = scaled.mem.data.2020.noNAs)

m7 <- lmer(fd ~ mpa + lfm + spp + (1 | individual), data = scaled.mem.data.2020.noNAs)
m7

m10 <- lmer(fd ~ lfm + spp + (1 | individual), data = scaled.mem.data.2020.noNAs)

m11 <- lmer(fd ~ mpa*spp + (1 | individual), data = scaled.mem.data.2020.noNAs)

#tab_model(top_model, m7, m10, m3, m6) 
tab_model(mpa_mod_fig.mpa, m11, m7, m10, m3, m6, 
          show.reflvl = TRUE, 
          digits = 3, 
          show.aic = TRUE, 
          show.ci = FALSE,
          show.icc = FALSE, 
          pred.labels = c('Intercept', 
                          'Water Potential (-Mpa)', 
                          'C. megacarpus',
                           'LFM (%)',
                          'Water weight (g)', 
                          'Dry weight (g)'), 
         dv.labels = c("Model 1", 
                       "Model 2", 
                       "Model 3", 
                       "Model 4", 
                       "Model 5", 
                       "Model 6"),
         string.pred = "Coeffcient",
  string.p = "P-Value", 
  p.style = "stars")
```


#### MPa vs. TTI, FH, GD

```{r}
tti.mpa <- ggplot() + 
  geom_point(data= scaled.mem.data.2020.noNAs, aes(mpa.unscaled, tti, color = Species), size = .5) + 
  geom_smooth(method = "lm", data= scaled.mem.data.2020, aes(mpa.unscaled, tti, color = Species), se = FALSE, size = .7) +
  #geom_line(data=x_mpa_fig, aes(x=mpa.unscaled, y=fit), color="#7570b3") +
  #geom_ribbon(data= x_mpa_fig, aes(x=mpa.unscaled, ymin=lower, ymax=upper), alpha= 0.3, fill="#7570b3") +
  labs(
    #x="Water Potential (-Mpa)", 
       y="Time to Ignition (sec)")  +
  scale_color_manual(values = c("blue2", "gold1")) +
  th +
  theme(axis.ticks.x = element_blank(),
        axis.text.x = element_blank(), 
        axis.title.x=element_blank(),
        legend.position = "none") 
tti.mpa


fh.mpa <- ggplot() + 
  geom_point(data= scaled.mem.data.2020.noNAs, aes(mpa.unscaled, fh, color = Species), size = .5) + 
  #geom_point(data=x_mpa_fig, aes(x=mpa.unscaled, y=fit), color="#7570b3", size = 1) +
  #geom_line(data=x_mpa_fig, aes(x=mpa.unscaled, y=fit), color="#7570b3") +
  geom_smooth(method = "lm", data= scaled.mem.data.2020, aes(mpa.unscaled, fh, color = Species), se = FALSE, size = .7) +
  #geom_ribbon(data= x_mpa_fig, aes(x=mpa.unscaled, ymin=lower, ymax=upper), alpha= 0.3, fill="#7570b3") +
  labs(
    #x="Water Potential (-Mpa)", 
       y="Flame Height (cm)")  +
  scale_color_manual(values = c("blue2", "gold1")) +
  th +
  theme(axis.ticks.x = element_blank(),
        axis.text.x = element_blank(), 
        axis.title.x=element_blank(),
        legend.position = "none") 
fh.mpa

gd.mpa <- ggplot() + 
  geom_point(data= scaled.mem.data.2020.noNAs, aes(mpa.unscaled, gd, color = Species), size = .5) + 
  #geom_point(data=x_mpa_fig, aes(x=mpa.unscaled, y=fit), color="#7570b3", size = 1) +
  #geom_line(data=x_mpa_fig, aes(x=mpa.unscaled, y=fit), color="#7570b3") +
  geom_smooth(method = "lm", data= scaled.mem.data.2020, aes(mpa.unscaled, gd, color = Species), se = FALSE, size = .7) +
  #geom_ribbon(data= x_mpa_fig, aes(x=mpa.unscaled, ymin=lower, ymax=upper), alpha= 0.3, fill="#7570b3") +
  labs(x="Water Potential (-Mpa)", 
       y="Glow Duration (sec)")  +
  scale_color_manual(values = c("blue2", "gold1")) +
  th +
  theme(legend.title = element_text(size = 10), 
        legend.text = element_text(size = 8), 
        legend.position = "bottom")
gd.mpa
```


```{r, fig1, fig.height = 6, fig.width = 3}
cowplot::plot_grid(tti.mpa, fh.mpa, gd.mpa, 
          ncol = 1)
```


#### LFM vs. TTI, FH, GD

```{r}
tti <- ggplot() + 
  geom_point(data= scaled.mem.data.2020.noNAs, aes(lfm.NAs.imputed, tti, color = Species), size = .5) + 
  geom_smooth(method = "lm", data= scaled.mem.data.2020, aes(lfm.NAs.imputed, tti, color = Species), se = FALSE, size = .7) +
  #geom_line(data=x_mpa_fig, aes(x=lfm, y=fit), color="#7570b3") +
  #geom_ribbon(data= x_mpa_fig, aes(x=lfm, ymin=lower, ymax=upper), alpha= 0.3, fill="#7570b3") +
  labs(
    #x="Live Fuel Moisture (%)", 
       y="Time to Ignition (sec)")  +
  scale_color_manual(values = c("blue2", "gold1")) +
  th +
  theme(axis.ticks.x = element_blank(),
        axis.text.x = element_blank(), 
        axis.title.x=element_blank(),
        legend.position = "none") 
tti


fh <- ggplot() + 
  geom_point(data= scaled.mem.data.2020.noNAs, aes(lfm.NAs.imputed, fh, color = Species), size = .5) + 
  #geom_point(data=x_mpa_fig, aes(x=lfm, y=fit), color="#7570b3", size = 1) +
  #geom_line(data=x_mpa_fig, aes(x=lfm, y=fit), color="#7570b3") +
  geom_smooth(method = "lm", data= scaled.mem.data.2020, aes(lfm.NAs.imputed, fh, color = Species), se = FALSE, size = .7) +
  #geom_ribbon(data= x_mpa_fig, aes(x=lfm, ymin=lower, ymax=upper), alpha= 0.3, fill="#7570b3") +
  labs(
    #x="Live Fuel Moisture (%)", 
       y="Flame Height (cm)")  +
  scale_color_manual(values = c("blue2", "gold1")) +
  th +
  theme(axis.ticks.x = element_blank(),
        axis.text.x = element_blank(), 
        axis.title.x=element_blank(),
        legend.position = "none") 
fh

gd <- ggplot() + 
  geom_point(data= scaled.mem.data.2020.noNAs, aes(lfm.NAs.imputed, gd, color = Species), size = .5) + 
  #geom_point(data=x_mpa_fig, aes(x=lfm, y=fit), color="#7570b3", size = 1) +
  #geom_line(data=x_mpa_fig, aes(x=lfm, y=fit), color="#7570b3") +
  geom_smooth(method = "lm", data= scaled.mem.data.2020, aes(lfm.NAs.imputed, gd, color = Species), se = FALSE, size = .7) +
  #geom_ribbon(data= x_mpa_fig, aes(x=lfm, ymin=lower, ymax=upper), alpha= 0.3, fill="#7570b3") +
  labs(x="Live Fuel Moisture (%)", 
       y="Glow Duration (sec)")  +
  scale_color_manual(values = c("blue2", "gold1")) +
  th +
  theme(legend.title = element_text(size = 10), 
        legend.text = element_text(size = 8), 
        legend.position = "bottom")
gd
```


```{r, fig1, fig.height = 2, fig.width = 1}
cowplot::plot_grid(tti, fh, gd, 
          ncol = 1)
```
#------------------------------------
#2.3. Segmented regression 


## Prop.ignite v LFM: 10% 

### ADFA

```{r}
out.lm<-lm(prop.ignite ~ lfm.unscaled, data = seg.adfa.subset)

#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

confint(segmented.mod)

fit <- numeric(length(seg.adfa.subset$lfm.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.adfa.subset$prop.ignite, seg.adfa.subset$lfm.unscaled)))] <- broken.line(segmented.mod)$fit

ggplot(seg.adfa.subset, aes(x = lfm.unscaled, y = prop.ignite)) + 
  geom_point(color = "blue2", size = .7) +
  geom_line(aes(x = lfm.unscaled, y = fit), color = "gold1") +
  labs(x = "Live Fuel Moisture (%)", 
       y = "Ignition Percentage (%)", 
       title = "A. fasciculatum") +
  #scale_color_manual(values = c("blue2", "gold1")) +
  th +
  geom_vline(xintercept = 74.33, color = "#7570b3")
```

### CEME

```{r}
out.lm<-lm(prop.ignite ~ lfm.unscaled, data = seg.CEME.subset)

#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

fit <- numeric(length(seg.CEME.subset$lfm.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.CEME.subset$prop.ignite, seg.CEME.subset$lfm.unscaled)))] <- broken.line(segmented.mod)$fit

ggplot(seg.CEME.subset, aes(x = lfm.unscaled, y = prop.ignite)) + 
  geom_point(color = "blue2", size = .7) +
  geom_line(aes(x = lfm.unscaled, y = fit), color = "gold1") +
  labs(x = "Live Fuel Moisture (%)", 
       y = "Ignition Percentage (%)", 
       title = "C. megacarpus") +
  #scale_color_manual(values = c("blue2", "gold1")) +
  th+
  geom_vline(xintercept = 88.96, color = "#7570b3")
```

## Zoomed in: 5%

Bins of 5 LFM used to make prop. ignite column

### ADFA

Significant P value! 

```{r}
out.lm<-lm(prop.ignite.bins5 ~ lfm.unscaled, data = seg.adfa.subset)

selgmented(out.lm)

davies.test(out.lm)
#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

fit <- numeric(length(seg.adfa.subset$lfm.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.adfa.subset$prop.ignite.bins5, seg.adfa.subset$lfm.unscaled)))] <- broken.line(segmented.mod)$fit

ggplot(seg.adfa.subset, aes(x = lfm.unscaled, y = prop.ignite.bins5)) + 
  geom_point(color = "blue2", size = .7) +
  geom_line(aes(x = lfm.unscaled, y = fit), color = "gold1") +
  labs(x = "Live Fuel Moisture (%)", 
       y = "Ignition Percentage (%)", 
       title = "A. fasciculatum") +
  #scale_color_manual(values = c("blue2", "gold1")) +
  th +
  geom_vline(xintercept = 74.33, color = "#7570b3")
```

### CEME

```{r}
out.lm<-lm(prop.ignite.bins5 ~ lfm.unscaled, data = seg.CEME.subset)

#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

fit <- numeric(length(seg.CEME.subset$lfm.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.CEME.subset$prop.ignite.bins5, seg.CEME.subset$lfm.unscaled)))] <- broken.line(segmented.mod)$fit

ggplot(seg.CEME.subset, aes(x = lfm.unscaled, y = prop.ignite.bins5))  + 
  geom_point(color = "blue2", size = .7) +
  geom_line(aes(x = lfm.unscaled, y = fit), color = "gold1") +
  labs(x = "Live Fuel Moisture (%)", 
       y = "Ignition Percentage (%)", 
       title = "C. megacarpus") +
  #geom_point(data=x_mpa_fig, aes(x=mpa.unscaled, y=fit), color="#7570b3", size = 1) +
 # geom_line(data=x_mpa_fig, aes(x=mpa.unscaled, y=fit), color="#db8872") +
 # geom_ribbon(data= x_mpa_fig, aes(x=mpa.unscaled, ymin=lower, ymax=upper), alpha= 0.3, fill="#db8872") +
  #scale_color_manual(values = c("blue2", "gold1")) +
  th +
  geom_vline(xintercept = 74.33, color = "#7570b3")
```
##Mpa 

### ADFA

```{r}
out.lm<-lm(prop.ignite.bins5 ~ mpa.unscaled, data = seg.adfa.subset)

#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

fit <- numeric(length(seg.adfa.subset$mpa.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.adfa.subset$prop.ignite.bins5, seg.adfa.subset$mpa.unscaled)))] <- broken.line(segmented.mod)$fit

ggplot(seg.adfa.subset, aes(x = mpa.unscaled, y = prop.ignite.bins5)) + 
  geom_point() +
  geom_line(aes(x = mpa.unscaled, y = fit), color = 'blue') +
  th
```

### CEME

```{r}
out.lm<-lm(prop.ignite.bins5 ~ mpa.unscaled, data = seg.CEME.subset)

#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

fit <- numeric(length(seg.CEME.subset$mpa.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.CEME.subset$prop.ignite.bins5, seg.CEME.subset$mpa.unscaled)))] <- broken.line(segmented.mod)$fit

ggplot(seg.CEME.subset, aes(x = mpa.unscaled, y = prop.ignite.bins5)) + 
  geom_point() +
  geom_line(aes(x = mpa.unscaled, y = fit), color = 'blue') +
  th
```

##tti

### ADFA

```{r}
out.lm<-lm(tti ~ mpa.unscaled, data = seg.adfa.subset)

#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

fit <- numeric(length(seg.adfa.subset$mpa.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.adfa.subset$tti, seg.adfa.subset$mpa.unscaled)))] <- broken.line(segmented.mod)$fit

ggplot(seg.adfa.subset, aes(x = mpa.unscaled, y = tti)) + 
  geom_point() +
  geom_line(aes(x = mpa.unscaled, y = fit), color = 'blue') +
  th
```

### CEME

```{r}
out.lm<-lm(tti ~ mpa.unscaled, data = seg.CEME.subset)

#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

fit <- numeric(length(seg.CEME.subset$mpa.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.CEME.subset$tti, seg.CEME.subset$mpa.unscaled)))] <- broken.line(segmented.mod)$fit

ggplot(seg.CEME.subset, aes(x = mpa.unscaled, y = tti)) + 
  geom_point() +
  geom_line(aes(x = mpa.unscaled, y = fit), color = 'blue') +
  th
```

##PC1

####ADFA

```{r}
out.lm<-lm(PC1 ~ lfm.unscaled, data = seg.adfa.subset)

#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

fit <- numeric(length(seg.adfa.subset$lfm.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.adfa.subset$PC1, seg.adfa.subset$lfm.unscaled)))] <- broken.line(segmented.mod)$fit

ggplot(seg.adfa.subset, aes(x = lfm.unscaled, y = PC1)) + 
  geom_point(color = "blue2", size = .7) +
  geom_line(aes(x = lfm.unscaled, y = fit), color = "gold1") +
  labs(x = "Live Fuel Moisture (%)", 
       y = "Ignition Percentage (%)", 
       title = "A. fasciculatum") +
  #scale_color_manual(values = c("blue2", "gold1")) +
  th +
  geom_vline(xintercept = 74.33, color = "#7570b3")
```

#### CEME

```{r}
out.lm<-lm(PC1 ~ lfm.unscaled, data = seg.CEME.subset)

#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

fit <- numeric(length(seg.CEME.subset$lfm.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.CEME.subset$PC1, seg.CEME.subset$lfm)))] <- broken.line(segmented.mod)$fit

ggplot(seg.CEME.subset, aes(x = lfm.unscaled, y = PC1)) + 
  geom_point(color = "blue2", size = .7) +
  geom_line(aes(x = lfm.unscaled, y = fit), color = "gold1") +
  labs(x = "Live Fuel Moisture (%)", 
       y = "PC1", 
       title = "C. megacarpus") +
  #scale_color_manual(values = c("blue2", "gold1")) +
  th+
  geom_vline(xintercept = 88.96, color = "#7570b3")
```
Next: Isolate just the LFM range we see in the wild and check just those for breakpoints. 

## TTI

### ADFA

```{r}
out.lm<-lm(tti ~ lfm.unscaled, data = seg.adfa.subset)

#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

fit <- numeric(length(seg.adfa.subset$lfm.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.adfa.subset$tti, seg.adfa.subset$lfm.unscaled)))] <- broken.line(segmented.mod)$fit

ggplot(seg.adfa.subset, aes(x = lfm.unscaled, y = tti)) + 
  geom_point(color = "blue2", size = .7) +
  geom_line(aes(x = lfm.unscaled, y = fit), color = "gold1") +
  labs(x = "Live Fuel Moisture (%)", 
       y = "Time to Ignition", 
       title = "A. fasciculatum") +
  #scale_color_manual(values = c("blue2", "gold1")) +
  th +
  geom_vline(xintercept = 74.33, color = "#7570b3")
```

### CEME

```{r}
out.lm<-lm(tti ~ lfm.unscaled, data = seg.CEME.subset)

#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

fit <- numeric(length(seg.CEME.subset$lfm.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.CEME.subset$tti, seg.CEME.subset$lfm.unscaled)))] <- broken.line(segmented.mod)$fit

ggplot(seg.CEME.subset, aes(x = lfm.unscaled, y = tti)) + 
  geom_point(color = "blue2", size = .7) +
  geom_line(aes(x = lfm.unscaled, y = fit), color = "gold1") +
  labs(x = "Live Fuel Moisture (%)", 
       y = "TTI", 
       title = "C. megacarpus") +
  #scale_color_manual(values = c("blue2", "gold1")) +
  th+
  geom_vline(xintercept = 88.96, color = "#7570b3")
```

## FH

### ADFA

```{r}
out.lm<-lm(fh ~ lfm.unscaled, data = seg.adfa.subset)

#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

fit <- numeric(length(seg.adfa.subset$lfm.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.adfa.subset$fh, seg.adfa.subset$lfm.unscaled)))] <- broken.line(segmented.mod)$fit

ggplot(seg.adfa.subset, aes(x = lfm.unscaled, y = fh)) + 
  geom_point(color = "blue2", size = .7) +
  geom_line(aes(x = lfm.unscaled, y = fit), color = "gold1") +
  labs(x = "Live Fuel Moisture (%)", 
       y = "Flame Height", 
       title = "A. fasciculatum") +
  #scale_color_manual(values = c("blue2", "gold1")) +
  th +
  geom_vline(xintercept = 74.33, color = "#7570b3")
```

### CEME

```{r}
out.lm<-lm(fh ~ lfm.unscaled, data = seg.CEME.subset)

#the simplest example: the starting model includes just 1 covariate
#.. and 1 breakpoint has to be estimated for that
segmented.mod <-segmented(out.lm) #1 breakpoint for x
segmented.mod

fit <- numeric(length(seg.CEME.subset$lfm.unscaled)) * NA

fit[complete.cases(rowSums(cbind(seg.CEME.subset$fh, seg.CEME.subset$lfm.unscaled)))] <- broken.line(segmented.mod)$fit

ggplot(seg.CEME.subset, aes(x = lfm.unscaled, y = fh)) + 
  geom_point(color = "blue2", size = .7) +
  geom_line(aes(x = lfm.unscaled, y = fit), color = "gold1") +
  labs(x = "Live Fuel Moisture (%)", 
       y = "fh", 
       title = "C. megacarpus") +
  #scale_color_manual(values = c("blue2", "gold1")) +
  th+
  geom_vline(xintercept = 88.96, color = "#7570b3")
```

#------------------------------------
#2.4 Logistic regression

####ADFA
```{r}
seg.adfa.subset.allignitions

##Use random effects model? 

# 1. baseline model glm
m0.glm = glm(ignition ~ 1, family = binomial, data = seg.adfa.subset.allignitions) 
# base-line mixed-model
m0.glmer = glmer(ignition ~ (1|id), data = seg.adfa.subset.allignitions, family = binomial) 

aic.glmer <- AIC(logLik(m0.glmer))
aic.glm <- AIC(logLik(m0.glm))
aic.glmer; aic.glm

#1 A. no evidence that including the random effect is justified (AIC is higher, and both are close)

# 2. test random effects
null.id = -2 * logLik(m0.glm) + 2 * logLik(m0.glmer)
pchisq(as.numeric(null.id), df=1, lower.tail=F) 

##2 A. not sig. better
```

```{r}
m1 <- glm(ignition ~ lfm, data = seg.adfa.subset.allignitions, family = "binomial")
summary(m1)
#not sig

m2 <- glm(ignition ~ mpa, data = seg.adfa.subset.allignitions, family = "binomial")
summary(m2)
#not sig

m3 <- glm(ignition ~ ww.flam.sample, data = seg.adfa.subset.allignitions, family = "binomial")
summary(m3)
#not sig

m4<- glm(ignition ~ dw.flam.sample, data = seg.adfa.subset.allignitions, family = "binomial")
summary(m4)
#not sig

m5 <- glm(ignition ~ lfm + mpa, data = seg.adfa.subset.allignitions, family = "binomial")
summary(m5)
#error, Warning: glm.fit: algorithm did not converge
#Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred

m6 <- glm(ignition ~ lfm + mpa + dw.flam.sample + ww.flam.sample, data = seg.adfa.subset.allignitions, family = "binomial")
summary(m6)
#not sig
#error, Warning: glm.fit: algorithm did not converge
#Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred

##P value, for kicks:
with(m6, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
```

####CEME
```{r}
seg.ceme.subset.allignitions

##Use random effects model? 

# 1. baseline model glm
m0.glm = glm(ignition ~ 1, family = binomial, data = seg.ceme.subset.allignitions) 
# base-line mixed-model
m0.glmer = glmer(ignition ~ (1|id), data = seg.ceme.subset.allignitions, family = binomial) 

aic.glmer <- AIC(logLik(m0.glmer))
aic.glm <- AIC(logLik(m0.glm))
aic.glmer; aic.glm

#1 A. no evidence that including the random effect is justified (AIC is higher, and both are close)

# 2. test random effects
null.id = -2 * logLik(m0.glm) + 2 * logLik(m0.glmer)
pchisq(as.numeric(null.id), df=1, lower.tail=F) 

##2 A. not sig. better
```

```{r}
m1 <- glm(ignition ~ lfm, data = seg.ceme.subset.allignitions, family = "binomial")
summary(m1)
#Lfm almost significant! p = 0.0828 .

m2 <- glm(ignition ~ mpa, data = seg.ceme.subset.allignitions, family = "binomial")
summary(m2)
#Warning: glm.fit: algorithm did not converge
#Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred

seg.ceme.subset.allignitions.noouts <- seg.ceme.subset.allignitions %>% 
  filter(ww.flam.sample < 4)
 
m3 <- glm(ignition ~ ww.flam.sample, data = seg.ceme.subset.allignitions.noouts, family = "binomial")
summary(m3)
#ww is significant! p =  0.0372 *

##P value: 
with(m3, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
#0.007564911

m3.1 <- glm(ignition ~ ww.flam.sample, data = seg.ceme.subset.allignitions, family = "binomial")
summary(m3.1)

m4<- glm(ignition ~ dw.flam.sample, data = seg.ceme.subset.allignitions, family = "binomial")
summary(m4)
#not sig

m5 <- glm(ignition ~ lfm + mpa, data = seg.ceme.subset.allignitions, family = "binomial")
summary(m5)
#Warning: glm.fit: algorithm did not converge
#Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred


m6 <- glm(ignition ~ lfm + mpa + dw.flam.sample + ww.flam.sample, data = seg.ceme.subset.allignitions, family = "binomial")
summary(m6)
#Warning: glm.fit: algorithm did not converge
#Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred

regclass::VIF(m6) ##everything except mpa has collinearity; dont use!
```

Plot 
```{r}
seg.ceme.subset.allignitions.noouts %>% 
  ggplot(aes(x=ww.flam.sample, y=ignition)) + 
  geom_point(alpha=.5) +
  stat_smooth(method="glm", se=FALSE, method.args = list(family=binomial))
```

#------------------------------------
#3. Physiology: MPa and LFM

```{r}
flam_phys_data_local <- read_csv(here("processed-data", "compiled-datasets", "flam_curve_phys_all.csv"))%>% 
  mutate(dataset = "flam") %>% 
 # mutate(month = month(month)) %>% 
  filter(spp %in% c("ADFA", "CEME"))

head(flam_phys_data_local)
```


```{r}
flam_phys_data_local %>% 
ggplot(aes(y = lfm.unscaled, x = mpa, color = spp, shape = year_month)) +
  geom_point() +
  geom_smooth(method = lm, se = FALSE)+
  th +
  scale_color_brewer(palette = "Dark2") +
  labs(y = "Live Fuel Moisture (%)", 
       x = "Water Potential (-MPa)", 
       color = "Species")
```

#------------------------------------
# EXTRA 
First attempt at using ggplot instead of biplot: 
```{r}
figure_princomp <- princomp(na.omit(figure_epi_pca_quant), center = TRUE, scale = TRUE)

figure_prcomp <- prcomp(na.omit(figure_epi_pca_quant), center = TRUE, scale = TRUE)

PCAvalues <- data.frame(Species = figure_epi_pca_cat$Species,
                        figure_prcomp$x) 

# Extract loadings of the variables
PCAloadings <- data.frame(Variables = rownames(figure_prcomp$rotation), figure_prcomp$rotation)

#Group by flam. metric: 
PCA_combustability <- PCAloadings %>% 
  filter(Variables %in% c("Flame Height", "Max. Temp","Flame Duration"))
         
PCA_ignitability <- PCAloadings %>% 
  filter(Variables %in% c("\n\nTime to Ignition", "\nTime to First Glow", "Glow to Ignition"))

PCA_consumability <- PCAloadings %>% 
  filter(Variables %in% c("Glow Duration", "Post-flame Glow"))


# Calculate the angles and the label offset
PCAloadings$Angle = ((180/pi) * atan(PCAloadings$PC2/PCAloadings$PC1))

PCAloadings$Offset <- ((-2 * sign(PCAloadings$PC1*4))/2)

#to make a sircle on the plot:
```
```{r}
seg_ceme_predicted <- predict(seg_CEME_mpa, seg.CEME.subset, se.fit = TRUE) %>% 
  as.data.frame()

seg_ceme_predicted_fuldf <- cbind(seg_ceme_predicted, seg.CEME.subset)
```

Varimax rotation attempt: 
```{r}
ncomp <- 2

pca_iris_rotated <- psych::principal(figure_epi_pca_quant, rotate="varimax", nfactors=ncomp, scores=TRUE)

princ_pca <- as.data.frame(pca_iris_rotated$scores)  # Scores returned by principal()

princ_pca_loadings <- as.data.frame(pca_iris_rotated$values) 


figure_prcomp <- prcomp(na.omit(figure_epi_pca_quant), center = TRUE, scale = TRUE)

rawLoadings <- figure_prcomp$rotation
rotatedLoadings <- varimax(rawLoadings)$loadings
invLoadings     <- t(pracma::pinv(rotatedLoadings))
scores          <- scale(figure_epi_pca_quant) %>% invLoadings
scores_df <- as.data.frame(print(scores))                  # Scores computed via rotated loadings


rawLoadings <- figure_prcomp$rotation
rotatedLoadings <- varimax(rawLoadings)$loadings
invLoadings     <- t(pracma::pinv(rotatedLoadings))
scores          <- scale(figure_epi_pca_quant) %>% invLoadings
scores_df <- as.data.frame(print(scores))                  # Scores computed via rotated loadings
PCAvalues <- data.frame(Species = figure_epi_pca_cat$Species, 
                        princ_pca
                        #scores_df
                        #figure_prcomp$x
                        ) %>% 
  mutate(PC1 = RC1, 
         PC2 = RC2) %>% 
  select(-RC1, - RC2)

# Extract loadings of the variables
PCAloadings <- data.frame(Variables = rownames(figure_prcomp$rotation),
                          princ_pca_loadings
                         # invLoadings
                         # figure_prcomp$rotation
                          ) %>% 
  mutate(PC1 = X1, 
         PC2 = X2) %>% 
  select(Variables, PC1, PC2)

#lengthen the loadings: 
# PCAloadings <- PCAloadings_small %>% 
#   mutate(PC1 = case_when(
#     PC1 > 0 ~ PC1 + 1, 
#     PC1 < 0 ~ PC1 - 1)) %>% 
#    mutate(PC2 = case_when(
#     PC1 > 0 ~ PC2 + 1, 
#     PC1 < 0 ~ PC2 - 1))
```

```{r, message=FALSE, results='hide'}
# Separating by Species
mpa_plot_spp <- ggplot() + 
  geom_point(data= scaled.mem.data.2020, aes(mpa, PC1, color = spp), size = .5) + 
 # geom_point(data=x_mpa_fig, aes(x=mpa, y=fit), color="#7570b3", size = .5) +
  geom_line(data=seg_CEME_mpa, aes(x=effects, y=fitted.values), color="#7570b3") +
  #geom_ribbon(data= seg_CEME_mpa, aes(x=mpa, ymin=lower, ymax=upper), alpha= 0.3, fill="#7570b3") +
  labs(x="Water Potential (-Mpa)", y="Principle Component 1") +
  scale_color_manual(values = c("blue2", "gold1")) +
  th
mpa_plot_spp
```
