---
title: 'Data Wrangling: Local Flam. Curves (SB Area)'
author: "Indra Boving"
date: "2/19/2021"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

#NOTES
- do we use proportion ignited?
  - if so, which metric or proportion ignited is used?
- we don't need hot plate stuff right?
- is there some way to streamline code so we don't have so many lines of code to look at outliers?

#SETUP

```{r}
#To load in necessary packages:
library(gapminder)
library(data.table)
library(purrr)
library(naniar)
library(tidyverse)
library(ggpubr)
library(simputation)
library(visdat)
library(here)
library(psych)
library(kableExtra)
filter = dplyr::filter #correct filter problem (gets confused with stats::filter)
here = here::here
read_csv = readr::read_csv
select = dplyr::select
```

This script deals with outliers and missing values in flammability metrics for tests conducted on C. megacarpus and A. fasciculatum outside Santa Barbara between 2016 and 2020 on both hotplate and epiradiator devices. 

In addition to measured metrics, it also computes other metrics from the data: flammability index (coposite metric that incorporates flame height and time to ignition in a single score), proportion ignited (bins of 5 and 10)
```{r warning=FALSE}
#Read in data:
raw.data <- read.csv(here("raw-data", "flam.local.alldates.csv")) 
```

# Clean up data:

### Deal with outliers in LFM: 

First, deal with values that don't make sense due to missingness (for
example, if the temp probe turned off and temp.max is listed as 0, or if
the weight is listed as 0, or if LFM is negative due to missing dry or
wet weight).

Do this to manipulated/controlled variables (weight, temp, mpa) as well
as with flammability metrics.

```{r}
#(need weird extra 0 types here for some reason?)
data.with.na <- raw.data %>% 
  replace_with_na(replace = list(temp.max = c(0, 0.0))) %>% #for missing temp maxs, make NA
  replace_with_na(replace = list(ignition.temp = c(0, 0.0))) %>% #for missing temp at ignition, make NA (all 2016 & 2018 trials)
  replace_with_na(replace = list(start.temp = c(0, 0.0))) %>% #for missing starting temp, make na
  replace_with_na(replace = list(sample.wt = c(0, 0.0))) %>% #for sample weight...
  replace_with_na(replace = list(lfm = c(0.00000))) #for missing lfm 

#To make any odd values due to lack of ignition 'NA':
data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "fh", "mpa",  "prop.new", "water.wt", "fresh.wt", "dry.wt")][(data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "fh", "mpa", "prop.new", "water.wt", "fresh.wt", "dry.wt")] == 0)] <- NA
data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "gti",  "dry.wt", "water.wt", "fresh.wt", "lfm")][(data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "gti",  "dry.wt", "water.wt", "fresh.wt", "lfm")] < 0)] <- NA
data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "gti")][(data.with.na[c("ttfg", "tti", "fd", "gd", "pfg", "gti")] > 1000)] <- NA
```

Next, visualize the impact of outliers in LFM with outlierKD function

(NOTE: outlierKD slightly changed here to NOT require yes/no input when
run. Instead, it is performed on a new column to retain unremoved data)

Details on OutlierKD: "To detect the outliers I use the command
boxplot.stats()\$out which use the Tukey's method to identify the
outliers ranged above and below the 1.5\*IQR."
(<https://www.r-bloggers.com/2016/04/identify-describe-plot-and-remove-the-outliers-from-the-dataset/>)

```{r}
##make column to take out outliers from lfm, while keeping column with original lfms too
data.with.na.outs <- data.with.na %>%
  mutate(lfm.outliers.out = lfm) %>%
  unite(year.month, c("year", "month"), remove = FALSE) %>%
  unite(year.month.spp, c("year", "month", "spp"), remove = FALSE)
```

```{r}
source("http://goo.gl/UUyEzD") #outlier KD (original function)

    #The following function is derived from outlierKD (from above)
outlierKD2 <- function(dt, var) {
  var_name <- eval(substitute(var),eval(dt))
  tot <- sum(!is.na(var_name))
  na1 <- sum(is.na(var_name))
  m1 <- mean(var_name, na.rm = T)
  par(mfrow=c(2, 2), oma=c(0,0,3,0))
  boxplot(var_name, main="With outliers")
  hist(var_name, main="With outliers", xlab=NA, ylab=NA)
  outlier <- boxplot.stats(var_name)$out
  mo <- mean(outlier)
  var_name <- ifelse(var_name %in% outlier, NA, var_name)
  boxplot(var_name, main="Without outliers")
  hist(var_name, main="Without outliers", xlab=NA, ylab=NA)
  title("Outlier Check", outer=TRUE)
  na2 <- sum(is.na(var_name))
  message("Outliers identified: ", na2 - na1, " from ", tot, " observations")
  message("Proportion (%) of outliers: ", (na2 - na1) / tot*100)
  message("Mean of the outliers: ", mo)
  m2 <- mean(var_name, na.rm = T)
  message("Mean without removing outliers: ", m1)
  message("Mean if we remove outliers: ", m2)
    dt[as.character(substitute(var))] <- invisible(var_name)
    assign(as.character(as.list(match.call())$dt), dt, envir = .GlobalEnv)
    message("Outliers successfully removed", "\n")
    return(invisible(dt))
}
```

#### CEME

```{r}
data.with.na.ceme <- data.with.na.outs %>% 
  filter(spp == "CEME")

#should not be difference between HP and EPI

outlierKD2(data.with.na.ceme, lfm.outliers.out) #check for outliers and remove (happens in outliers.out column, lfm column still contains outliers)

data.with.na.ceme <- data.with.na.ceme %>% 
 mutate(lfm = ifelse(lfm > 400, NA, lfm)) #take out unreasonable values
```

#### ADFA

```{r}
data.with.na.adfa <- data.with.na.outs %>% 
  filter(spp == "ADFA")

outlierKD2(data.with.na.adfa, lfm.outliers.out) #check for outliers and remove (happens in outliers.out column, lfm column still contains outliers)

data.with.na.adfa <- data.with.na.adfa %>% 
 mutate(lfm = ifelse(lfm > 200, NA, lfm))
```

```{r}
data.with.na.new <- rbind(data.with.na.adfa, data.with.na.ceme)
```

# Impute missing values:

```{r}
#impute rlm for each spp. 
data.with.na.imputed <- data.with.na.new %>%
  mutate(lfm.NAs.imputed = lfm.outliers.out) %>%
  impute_rlm(lfm.NAs.imputed ~ mpa + dry.wt + fresh.wt | year.month.spp)
```

# Add new variables:

Add some columns to the dataframe and manipulate some variables:

-   Add precip columns with 2 month previous precipitation (from SBBG
    daily precip. database, see Precip_SB_DATE.Rmd file for tidying that
    data).
-   Proportion ignite columns: for each increase in LFM of 10% or 5%, what
    proportion of the attempted burns ignited?

### Prop ignite: 

```{r ,include=FALSE}
data <- data.with.na.imputed %>% 
  #group_by(gr = cut(lfm.NAs.imputed, breaks= seq(0, 400, by = 10))) %>% #create 10 lfm.NAs.imputed segments, indicate these in new column called "gr"
  group_by(gr = cut(lfm, breaks= seq(0, 400, by = 10))) %>%
  ungroup() %>% #ungroup - this will stop issues in the future (we can always regroup again)
  group_by(year, month, model, spp, gr) %>% #create groups based on trial, model, species, and lfm segment
  add_tally %>% #column with n for each of these groups
  ungroup() %>% #ungroup so r doesnt get confused
  unite(model.spp.gr, c("year", "month", "model", "spp", "gr"), remove = FALSE) %>% #create column for each group as above, which will be associated with the n of each group based on the above add_tally step. 
  unite(model.spp.gr.sample, c("year", "month", "model", "spp", "gr", "sample"), remove = FALSE) %>% #create column with group for each indvidual sample (this is a unique ID)
  mutate(individual = model.spp.gr.sample) %>% 
  #group for month and year
  mutate(precip.2month = year.month) %>%
 mutate(precip.2mo = recode(precip.2month, "2020_September" = 0.01, "2018_January" = 0.09, "2019_December" = 3.69, "2020_January" = 5.82, "2016_December" = 0.61)) %>%
  mutate(season = year.month) %>%
  mutate(season = recode(season, "2020_September" = "Dry", "2018_January" = "Dry", "2019_December" = "Wet", "2020_January" = "Wet", "2016_December" = "Dry" )) %>%  #group for month and year
  group_by(model.spp.gr)#group by year, model, spp, group column
 
setDT(data)[,total:=sum(ignition),by=model.spp.gr][] #add column called "total" with the total number of ignitions per group ("sum" works because we have 0s and 1s)

data <-  data %>%
  mutate(prop.ignite = paste0(round(100 * total/n))) %>% #for each group, divide total ignitions ("total" column) by total number burn attempts (n column), as a percentage
  ungroup() %>% #ungroup so r doesnt get confused
  #create Rate of Spread column (only relevant for HP metrics, but we'll do it for all and just ignore that column when we do EPI analysis):
  mutate(ros = 10/fd) %>% ##this returns Inf for those missing flame duration (i.e., no burn columns. Shouldnt be an issue when we filter out only those that burned); not relevant for Epiradiator samples, but we'll do it to those anyway and then ignore or filter out that column later. 
  dplyr::select(-n, -total, lfm) #remove columns we aren't interested in anymore

data$prop.ignite <- as.numeric(data$prop.ignite) #Since, otherwise, it would be a character vector
```

#prop.ignite with bins of 5 

```{r}
data.5bins <- data %>% 
  group_by(bins5lfm_gr = cut(lfm, breaks= seq(0, 400, by = 5))) %>% #create 10 lfm.NAs.imputed segments, indicate these in new column called "gr"
  ungroup() %>% #ungroup - this will stop issues in the future (we can always regroup again)
  group_by(year, month, model, spp, bins5lfm_gr) %>% #create groups based on trial, model, species, and lfm segment
  add_tally %>% #column with n for each of these groups
  ungroup() %>% #ungroup so r doesnt get confused
  unite(model.spp.bins5lfm_gr, c("year", "month", "model", "spp", "bins5lfm_gr"), remove = FALSE) %>% #create column for each group as above, which will be associated with the n of each group based on the above add_tally step. 
  unite(model.spp.bins5lfm_gr.sample, c("year", "month", "model", "spp", "bins5lfm_gr", "sample"), remove = FALSE) %>% #create column with group for each indvidual sample (this is a unique ID)
  mutate(individual.bins5lfm_gr = model.spp.bins5lfm_gr.sample) %>% 
  group_by(individual.bins5lfm_gr)#group by year, model, spp, group column
 
setDT(data.5bins)[,total_bins5lfm_gr:=sum(ignition),by=model.spp.bins5lfm_gr][] #add column called "total" with the total number of ignitions per group ("sum" works because we have 0s and 1s)

data.5bins <-  data.5bins %>%
  mutate(prop.ignite.bins5 = paste0(round(100 * total_bins5lfm_gr/n))) %>% #for each group, divide total ignitions ("total" column) by total number burn attempts (n column), as a percentage
  ungroup() %>% #ungroup so r doesnt get confused
  #create Rate of Spread column (only relevant for HP metrics, but we'll do it for all and just ignore that column when we do EPI analysis):
  select(-n, -total_bins5lfm_gr) #remove columns we aren't interested in anymore

data.5bins$prop.ignite.bins5 <- as.numeric(data.5bins$prop.ignite.bins5) #Since, otherwise, it would be a character vector
```

Need to do the above, but without grouping by trial date
```{r}
data.5bins_nodate <- data.5bins %>% 
  #group_by(bins5lfm_gr = cut(lfm.NAs.imputed, breaks= seq(0, 400, by = 5))) %>% #create 10 lfm.NAs.imputed segments, indicate these in new column called "gr", did that already
  ungroup() %>% #ungroup - this will stop issues in the future (we can always regroup again)
  group_by(model, spp, bins5lfm_gr) %>% #create groups based on trial, model, species, and lfm segment
  add_tally %>% #column with n for each of these groups
  ungroup() %>% #ungroup so r doesnt get confused
  unite(model.spp.bins5lfm_gr_nodate, c("model", "spp", "bins5lfm_gr"), remove = FALSE) %>% #create column for each group as above, which will be associated with the n of each group based on the above add_tally step. 
  unite(model.spp.bins5lfm_gr.sample_nodate, c("model", "spp", "bins5lfm_gr", "sample"), remove = FALSE) %>% #create column with group for each indvidual sample (this is a unique ID)
  mutate(individual.bins5lfm_gr_nodate = model.spp.bins5lfm_gr.sample_nodate) %>% 
  group_by(individual.bins5lfm_gr_nodate)#group by year, model, spp, group column
 
setDT(data.5bins_nodate)[,total_bins5lfm_gr_nodate:=sum(ignition),by=model.spp.bins5lfm_gr_nodate][] #add column called "total" with the total number of ignitions per group ("sum" works because we have 0s and 1s)

data.5bins_nodate <-  data.5bins_nodate %>%
  mutate(prop.ignite.bins5_nodate = paste0(round(100 * total_bins5lfm_gr_nodate/n))) %>% #for each group, divide total ignitions ("total" column) by total number burn attempts (n column), as a percentage
  ungroup() %>% #ungroup so r doesnt get confused
  #create Rate of Spread column (only relevant for HP metrics, but we'll do it for all and just ignore that column when we do EPI analysis):
  select(-n, -total_bins5lfm_gr_nodate) #remove columns we aren't interested in anymore

data.5bins_nodate$prop.ignite.bins5_nodate <- as.numeric(data.5bins_nodate$prop.ignite.bins5_nodate) #Since, otherwise, it would be a character vector
```

```{r}
data.10bins_nodate <- data.5bins_nodate %>% 
  group_by(bins10lfm_gr = cut(lfm, breaks= seq(0, 400, by = 10))) %>% #create 10 lfm.NAs.imputed segments, indicate these in new column called "gr", did that already
  ungroup() %>% #ungroup - this will stop issues in the future (we can always regroup again)
  group_by(model, spp, bins10lfm_gr) %>% #create groups based on trial, model, species, and lfm segment
  add_tally %>% #column with n for each of these groups
  ungroup() %>% #ungroup so r doesnt get confused
  unite(model.spp.bins10lfm_gr_nodate, c("model", "spp", "bins10lfm_gr"), remove = FALSE) %>% #create column for each group as above, which will be associated with the n of each group based on the above add_tally step. 
  unite(model.spp.bins10lfm_gr.sample_nodate, c("model", "spp", "bins10lfm_gr", "sample"), remove = FALSE) %>% #create column with group for each indvidual sample (this is a unique ID)
  mutate(individual.bins10lfm_gr_nodate = model.spp.bins10lfm_gr.sample_nodate) %>% 
  group_by(individual.bins10lfm_gr_nodate)#group by year, model, spp, group column
 
setDT(data.10bins_nodate)[,total_bins10lfm_gr_nodate:=sum(ignition),by=model.spp.bins10lfm_gr_nodate][] #add column called "total" with the total number of ignitions per group ("sum" works because we have 0s and 1s)

data.10bins_nodate <-  data.10bins_nodate %>%
  mutate(prop.ignite.bins10_nodate = paste0(round(100 * total_bins10lfm_gr_nodate/n))) %>% #for each group, divide total ignitions ("total" column) by total number burn attempts (n column), as a percentage
  ungroup() %>% #ungroup so r doesnt get confused
  #create Rate of Spread column (only relevant for HP metrics, but we'll do it for all and just ignore that column when we do EPI analysis):
  select(-n, -total_bins10lfm_gr_nodate) #remove columns we aren't interested in anymore

data.10bins_nodate$prop.ignite.bins10_nodate <- as.numeric(data.10bins_nodate$prop.ignite.bins10_nodate) #Since, otherwise, it would be a character vector
```


```{r}
data <- data.10bins_nodate 
```
-   Categorical "dry" vs. "wet" vs. "moderate" column for season, based
    on prior precip and date (dry = <1 in rain, wet = >3 in rain)
-   Various categorical groups based on LFM, spp., models, date, etc.
    used in grouping later on or in creating the above columns.
-   Column labeled "hydration" with break at 60% LFM for dry, 60 - 90%
    for moderate, and \> 100% for hydrated
-   Make bins of varying lfm sizes (5, 10, 20)


```{r, include= FALSE}
#impute lfm based on relationship with Mpa, grouping by species:
data <- data %>%
  group_by(spp) %>%
#then create bins for LFM, in case we want to compare via bins
  mutate(hydration = cut(lfm, breaks = c(0, 60, 90, 400), labels = c("dry", "moderate", "hydrated"), ordered_result = TRUE)) %>% 
  ungroup() %>%
  group_by(bins5lfm= cut(lfm, breaks= seq(0, 400, by = 5), ordered_result = TRUE)) %>% #create 10 LFM segments, indicate these in new column called "bins5lfm"
  ungroup() %>% #ungroup - this will stop issues in the future (we can always regroup again)
  group_by(bins10lfm= cut(lfm, breaks= seq(0, 400, by = 10), ordered_result = TRUE)) %>% #create 10 LFM segments, indicate these in new column called "bins10lfm"
  ungroup() %>% #ungroup - this will stop issues in the future (we can always regroup again)
  group_by(bins20lfm = cut(lfm, breaks= seq(0, 400, by = 20), ordered_result = TRUE)) %>% #create 20 LFM segments, indicate these in new column called "bins20lfm"
  ungroup() 
```


### Other missing values: weights and temps

```{r include=FALSE}
#view: 
#impute values for missing weights:
data <- data %>%
  unite(individual, c("year", "month", "spp", "sample"), remove = FALSE) %>% #create 'individual' column
  dplyr::group_by(model.spp.gr) %>%
  impute_median_at(c("dry.wt", "fresh.wt", "water.wt", "sample.wt")) %>%
  ungroup() %>%
  impute_median_at("start.temp") %>%
  mutate(temp.change = temp.max - start.temp)
```

We also make a dataset to use in PV curve from flam curve analysis.

```{r}
# # Make dry weight columns, etc. for PV comparison: 

# (EDIT: PV Sat.weight stuff needs to happen in excel due to need for extrapolation..this is still interesting though)

#calculate metrics for weight values (read . as "per", i.e. gdw.gfw is "gram dry weight per gram fresh weight"):
data <- data %>%
  dplyr::mutate(gdw.gfw = dry.wt/fresh.wt) %>%
  dplyr:::mutate(gww.gdw = lfm.NAs.imputed/100) %>%
  dplyr::mutate(gdw.gww = dry.wt/water.wt) %>%
  dplyr::mutate(dw.flam.sample = sample.wt * gdw.gfw) %>%
  dplyr::mutate(ww.flam.sample = sample.wt - dw.flam.sample, 
         ww.outs = ww.flam.sample,
         dw.outs = dw.flam.sample) %>%
  replace_with_na_at(.vars = c("ww.flam.sample"), condition = ~.x < 0) # oe was below 0 (due to missing lfm), so remove that one 

```
#### wet weights

```{r}
#to filter out different values for HP or EPI: 
groupkind <- c('EPI', 'HP')

for(model in groupkind) {
          if(model == 'EPI') outlierKD2(data, ww.outs)
          else if(model == 'HP') outlierKD2(data, ww.outs)
}
```

Remove very high ww

```{r}
###just seperate: 

data.hp <- data %>% 
  filter(model == "HP", 
         ww.flam.sample < 1.6)

data.epi <- data %>% 
  filter(model == "EPI", 
         ww.flam.sample < .75)
```

#### dry weights

```{r}
outlierKD2(data.hp, dw.outs)
outlierKD2(data.epi, dw.outs)
```

```{r}
data.epi %>% 
ggplot() +
  geom_point(aes(y = dw.flam.sample, x = mpa), color = "blue") +
  geom_point(aes(y = dw.outs, x = mpa), color = "goldenrod")
```
Remove very high: 

```{r}
data.epi <- data.epi %>% 
  filter(dw.flam.sample < 0.46)
```

```{r}
data.hp %>% 
ggplot() +
  geom_point(aes(y = dw.flam.sample, x = mpa), color = "blue") +
  geom_point(aes(y = dw.outs, x = mpa), color = "goldenrod")
```
Remove very high: 

```{r}
data.hp <- data.hp %>% 
  filter(dw.flam.sample < 2)

data <- rbind(data.hp, data.epi)
```

```{r}
#deal with weight values from the above (should actually not be needed)
data <- data %>%
  dplyr::group_by(model.spp.gr) %>%
  impute_median_at("ww.flam.sample") %>%
  dplyr::group_by(model.spp.gr) %>%
  dplyr::group_by(individual) %>% 
  dplyr::mutate(gww.gdw.saturated = max((gww.gdw), na.rm = TRUE)) %>%
  dplyr::mutate(gdw.gww.saturated = min((gdw.gww), na.rm = TRUE)) %>%
  mutate(RWC = (gww.gdw/gww.gdw.saturated)*100) %>%
  mutate(RWD = 100 - RWC) %>%
  mutate(max.mpa.sample = max((mpa), na.rm = TRUE)) 


rwc.data <- data %>% select(individual, year.month, dry.wt, spp, model, lfm.NAs.imputed, RWC, max.mpa.sample, mpa, gww.gdw, gww.gdw.saturated, fresh.wt, dry.wt, site, sample, lfm)
```

------------------------------------------------------------------------

```{r}
data_flam_outs <- data %>% 
  mutate(tti.outs = tti, 
         gti.outs = gti, 
         gd.outs = gd, 
         fd.outs = fd, 
         pfg.outs = pfg, 
         fh.outs= fh, 
         temp.max.outs = temp.max, 
         ignition.temp.outs = ignition.temp
         )
```


# CEME only:

```{r}
data.ceme <- data_flam_outs %>% 
  filter(spp == "CEME")
```

```{r}
ignite.only.ceme.epi <- data.ceme %>%
  filter(ignition == "1") %>% #only look at ignited samples
  filter(model == "EPI")

ignite.only.ceme.hp <- data.ceme %>%
  filter(ignition == "1") %>% #only look at ignited samples
  filter(model == "HP")
```


## Other missing values: Flam metrics

### EPI and HP

### Outliers in flam metrics:

These run and remove outliers automatically, need to quiet the code if
that is not what we want.

#### tti

```{r}
outlierKD2(ignite.only.ceme.epi, tti.outs)
outlierKD2(ignite.only.ceme.hp, tti.outs)
```

```{r}
ignite.only.ceme.epi %>% 
ggplot() +
  geom_point(aes(y = tti, x = mpa), color = "blue") +
  geom_point(aes(y = tti.outs, x = mpa), color = "goldenrod")
```
Don't remove any 

```{r}
ignite.only.ceme.hp %>% 
ggplot() +
  geom_point(aes(y = tti, x = mpa), color = "blue") +
  geom_point(aes(y = tti.outs, x = mpa), color = "goldenrod")
```
Dont remove any
#### gti

```{r}
outlierKD2(ignite.only.ceme.epi, gti.outs)
outlierKD2(ignite.only.ceme.hp, gti.outs)
```
```{r}
ignite.only.ceme.epi %>% 
ggplot() +
  geom_point(aes(y = gti, x = mpa), color = "blue") +
  geom_point(aes(y = gti.outs, x = mpa), color = "goldenrod")
```
Dont remove

```{r}
ignite.only.ceme.hp %>% 
ggplot() +
  geom_point(aes(y = gti, x = mpa), color = "blue") +
  geom_point(aes(y = gti.outs, x = mpa), color = "goldenrod")
```
#### gd

```{r}
outlierKD2(ignite.only.ceme.epi, gd.outs)
outlierKD2(ignite.only.ceme.hp, gd.outs)
```
```{r}
ignite.only.ceme.epi %>% 
ggplot() +
  geom_point(aes(y = gd, x = mpa), color = "blue") +
  geom_point(aes(y = gd.outs, x = mpa), color = "goldenrod")
```
Dont remove

```{r}
ignite.only.ceme.hp %>% 
ggplot() +
  geom_point(aes(y = gd, x = mpa), color = "blue") +
  geom_point(aes(y = gd.outs, x = mpa), color = "goldenrod")
```

#### fd

```{r}
outlierKD2(ignite.only.ceme.epi, fd.outs)
outlierKD2(ignite.only.ceme.hp, fd.outs)
```
```{r}
ignite.only.ceme.epi %>% 
ggplot() +
  geom_point(aes(y = fd, x = mpa), color = "blue") +
  geom_point(aes(y = fd.outs, x = mpa), color = "goldenrod")
```
Remove the point that is an obvious outlier at 0 mpa:
```{r}
ignite.only.ceme.epi <- ignite.only.ceme.epi %>% 
 mutate(fd = ifelse(fd > 30 | mpa > -1, NA, fd))
```

```{r}
ignite.only.ceme.hp %>% 
ggplot() +
  geom_point(aes(y = fd, x = mpa), color = "blue") +
  geom_point(aes(y = fd.outs, x = mpa), color = "goldenrod")
```
#### pfg

```{r}
outlierKD2(ignite.only.ceme.epi, pfg.outs)
outlierKD2(ignite.only.ceme.hp, pfg.outs)
```
```{r}
ignite.only.ceme.epi %>% 
ggplot() +
  geom_point(aes(y = pfg, x = mpa), color = "blue") +
  geom_point(aes(y = pfg.outs, x = mpa), color = "goldenrod")
```
Dont remove

```{r}
ignite.only.ceme.hp %>% 
ggplot() +
  geom_point(aes(y = pfg, x = mpa), color = "blue") +
  geom_point(aes(y = pfg.outs, x = mpa), color = "goldenrod")
```
remove one weirdly high value (did not ignite? probably miscoded)

```{r}
ignite.only.ceme.hp <- ignite.only.ceme.hp %>% 
  filter(pfg < 199)
```


#### fh

```{r}
outlierKD2(ignite.only.ceme.epi, fh.outs)
outlierKD2(ignite.only.ceme.hp, fh.outs)
```

```{r}
ignite.only.ceme.epi %>% 
ggplot() +
  geom_point(aes(y = fh, x = mpa), color = "blue") +
  geom_point(aes(y = fh.outs, x = mpa), color = "goldenrod")
```
Remove high value at ~0 MPa

```{r}
ignite.only.ceme.epi <- ignite.only.ceme.epi %>% 
  mutate(fh = ifelse(fh > 20 | mpa > -1, NA, fh))
```

```{r}
ignite.only.ceme.hp %>% 
ggplot() +
  geom_point(aes(y = fh, x = mpa), color = "blue") +
  geom_point(aes(y = fh.outs, x = mpa), color = "goldenrod")
```

#### temp max

```{r}
outlierKD2(ignite.only.ceme.epi, temp.max.outs)
outlierKD2(ignite.only.ceme.hp, temp.max.outs)
```
```{r}
ignite.only.ceme.epi %>% 
ggplot() +
  geom_point(aes(y = temp.max, x = mpa), color = "blue") +
  geom_point(aes(y = temp.max.outs, x = mpa), color = "goldenrod")
```
Dont remove

```{r}
ignite.only.ceme.hp %>% 
ggplot() +
  geom_point(aes(y = temp.max, x = mpa), color = "blue") +
  geom_point(aes(y = temp.max.outs, x = mpa), color = "goldenrod")
```
#### ignition temp

```{r}
outlierKD2(ignite.only.ceme.epi, ignition.temp.outs)
outlierKD2(ignite.only.ceme.hp, ignition.temp.outs)
```
```{r}
ignite.only.ceme.epi %>% 
ggplot() +
  geom_point(aes(y = ignition.temp, x = mpa), color = "blue") +
  geom_point(aes(y = ignition.temp.outs, x = mpa), color = "goldenrod")
```
Look at distributions of flammability metrics so we can think about how
to deal with NAs in those variables, and then deal with them.

```{r}
ignite.only.ceme.hp %>% 
ggplot() +
  geom_point(aes(y = ignition.temp, x = mpa), color = "blue") +
  geom_point(aes(y = ignition.temp.outs, x = mpa), color = "goldenrod")
```

### Outliers in flam metrics:

#### Distribution following imputation: 

```{r, include=FALSE}
### Subset data and perform imputations (median):
#str(data)
ignite.only.ceme.epi %>%
  mutate(gti = as.numeric(gti)) 

ignite.only.ceme.epi <- ignite.only.ceme.epi %>%
  group_by(year.month) %>% 
  group_by(spp) %>% #this makes us take the median of based on the species, the model, and the lfm bins (of 10 lfm) the missing value is in. Preserves species differences, and lfm impact. 
  impute_median_at(c("ttfg", "gd", "gti", "fd", "pfg","temp.max", "start.temp", "ros", "ignition.temp", "temp.change", "prop.ignite", "fh", "tti")) 
```

```{r, include=FALSE}
### Subset data and perform imputations (median):
#str(data)
ignite.only.ceme.hp %>%
  mutate(gti = as.numeric(gti)) 

ignite.only.ceme.hp <- ignite.only.ceme.hp %>%
  group_by(year.month) %>% 
  group_by(spp) %>% #this makes us take the median of based on the species, the model, and the lfm bins (of 10 lfm) the missing value is in. Preserves species differences, and lfm impact. 
  impute_median_at(c("ttfg", "gd", "gti", "fd", "pfg","temp.max", "start.temp", "ros", "ignition.temp", "temp.change", "prop.ignite", "fh", "tti")) %>% 
  dplyr::mutate(gti = replace(gti, gti == "0", "0.5")) %>% #replace when gti is zero to .5 seconds, so we can take the log later
  mutate(gti = as.numeric(gti))%>% 
  impute_lm(fh ~ spp + lfm.NAs.imputed)
```


# Look at flam characteristics to see if they make sense:

#### For EPI only:

```{r, include=FALSE}
ignite.only.ceme.epi <- ignite.only.ceme.epi %>%
  mutate(flam.index = 3*((75+tti)/(12.5+tti))*exp(fh/(fh+27))) #using max tti and max fh, becomes a scale of least (1) to most (20) flammable 
```

#### For HP only:

```{r, include = FALSE}
ignite.only.ceme.hp <- ignite.only.ceme.hp %>%
  mutate(flam.index = 3.45*((214+tti)/(12.5+tti))*exp(fh/(fh+38))) #using max tti and max fh, becomes a scale of least (1) to most (20) flammable
```



Combine both EPI and HP back into master dataset called
"ignite.only.ceme.all"

```{r, include=FALSE}
ignite.only.ceme.all <- rbind(ignite.only.ceme.epi, ignite.only.ceme.hp)
```

### EPI only:

Here we are normalizing by the dry weight of the flammability sample,
which was calculated by multiplying the weight of the burned sample by
the ratio of dry weight to fresh weight in the samples used for lfm
measurements.

(Assumptions here: that the ratio of water to dry weight in burned and
lfm samples was the same)

```{r}
distributions.lfm <- ignite.only.ceme.epi %>%
  ggplot() +
  geom_density(aes(x = sample.wt, color = spp)) 
distributions.lfm  

ignite.only.ceme.epi <- ignite.only.ceme.epi %>%  #Dealing with only EPI trials that ignited (can change later)
  dplyr::mutate(mean.wt = mean(sample.wt, na.rm = TRUE)) %>% #take the mean of all sample weights for each model
  ungroup() %>% 
  mutate_if(is.integer, as.numeric) 

ignite.only.ceme.epi$gti <- as.numeric(as.character(ignite.only.ceme.epi$gti)) #not sure why this became a character...
#str(ignite.only.ceme.epi)

distributions.lfm <- ignite.only.ceme.epi %>%
  ggplot() +
  geom_density(aes(x = lfm.NAs.imputed, color = spp))
distributions.lfm 

distributions.lfm <- ignite.only.ceme.epi %>%
  ggplot() +
  geom_density(aes(x = ww.flam.sample, color = spp))
distributions.lfm
```

```{r, include=FALSE}
ignite.only.ceme.epi <- ignite.only.ceme.epi %>%
  mutate(gti = replace(gti, gti == "0", "0.5")) %>% 
  mutate(gti = as.numeric(gti)) %>%
  mutate("dry.norm.fh" = fh/dw.flam.sample) %>% #create new columns, etc.
  mutate("dry.norm.gd" = gd/dw.flam.sample) %>%
  mutate("dry.norm.fd" = fd/dw.flam.sample) %>%
  mutate("dry.norm.pfg" = pfg/dw.flam.sample) %>%
  mutate("dry.norm.ttfg" = ttfg/dw.flam.sample) %>%
  mutate("dry.norm.tti" = tti/dw.flam.sample) %>% 
  mutate("dry.norm.gti" = gti/dw.flam.sample) 
#str(ignite.only.ceme.epi)
```


### EPI (USE THIS FOR PCA): Mirroring Max's PCA dataset (Mac_PCA_DATE.Rmd)

```{r, include=FALSE}
epi.ignite.only.ceme.PCA <- ignite.only.ceme.epi %>%
  mutate(mpa = mpa * -1) 
```

### HP only:

Here we are normalizing by the dry weight of the flammability sample,
which was calculated by multiplying the weight of the burned sample by
the ratio of dry weight to fresh weight in the samples used for lfm
measurements. (Assumptions here: that the ratio of water to dry weight
in burned and lfm samples was the same)

```{r}
#colSums(is.na(ignite.only.ceme.hp))
#str(ignite.only.ceme.hp)
ignite.only.ceme.hp <- ignite.only.ceme.hp %>%  #Dealing with only EPI trials that ignited (can change later)
  dplyr::mutate(mean.wt = mean(sample.wt, na.rm = TRUE)) %>% #take the mean of all sample weights for each model
  ungroup() %>% 
  mutate_if(is.integer, as.numeric) 

ignite.only.ceme.hp$gti <- as.numeric(as.character(ignite.only.ceme.hp$gti)) #not sure why this became a character...
#str(ignite.only.ceme.hp)

#range(ignite.only.ceme.hp$dw.flam.sample) #range gets low for some samples (with very low lfm, maybe?)
```

```{r, include=FALSE}
ignite.only.ceme.hp <- ignite.only.ceme.hp %>%
  mutate(gti = replace(gti, gti == "0", "0.5")) %>% 
  mutate(gti = as.numeric(gti)) %>%
  mutate("dry.norm.fh" = fh/dw.flam.sample) %>% #create new columns, etc.
  mutate("dry.norm.gd" = gd/dw.flam.sample) %>%
  mutate("dry.norm.fd" = fd/dw.flam.sample) %>%
  mutate("dry.norm.pfg" = pfg/dw.flam.sample) %>%
  mutate("dry.norm.ttfg" = ttfg/dw.flam.sample) %>%
  mutate("dry.norm.tti" = tti/dw.flam.sample) %>% 
  mutate("dry.norm.gti" = gti/dw.flam.sample) %>%
  mutate("temp.change" = temp.max - start.temp) 

#str(ignite.only.ceme.hp)
```


### HP (USE THIS FOR PCA): Mirroring Max's PCA dataset (Mac_PCA_DATE.Rmd)

```{r, include=FALSE}
hp.ignite.only.ceme.pca <- ignite.only.ceme.hp %>%
  mutate(mpa = mpa * -1) %>%
  relocate("hydration")
```

------------------------------------------------------------------------

# ADFA only:

## Other missing values: Flam metrics

### EPI: only

```{r}
data.adfa <- data_flam_outs %>% 
  filter(spp == "ADFA")
```

```{r}
ignite.only.adfa.epi <- data.adfa %>%
  filter(ignition == "1") %>% #only look at ignited samples
  filter(model == "EPI")
```

### Outliers in flam metrics:

These run and remove outliers automatically, need to quiet the code if
that is not what we want.

#### tti

```{r}
outlierKD2(ignite.only.adfa.epi, tti.outs)
```
```{r}
ignite.only.adfa.epi %>% 
ggplot() +
  geom_point(aes(y = tti, x = mpa), color = "blue") +
  geom_point(aes(y = tti.outs, x = mpa), color = "goldenrod")
```
#### gti

```{r}
outlierKD2(ignite.only.adfa.epi, gti.outs)
```
```{r}
ignite.only.adfa.epi %>% 
ggplot() +
  geom_point(aes(y = gti, x = mpa), color = "blue") +
  geom_point(aes(y = gti.outs, x = mpa), color = "goldenrod")
```
#### gd

```{r}
outlierKD2(ignite.only.adfa.epi, gd.outs)
```

```{r}
ignite.only.adfa.epi %>% 
ggplot() +
  geom_point(aes(y = gd, x = mpa), color = "blue") +
  geom_point(aes(y = gd.outs, x = mpa), color = "goldenrod")
```

#### fd

```{r}
outlierKD2(ignite.only.adfa.epi, fd.outs)
```
```{r}
ignite.only.adfa.epi %>% 
ggplot() +
  geom_point(aes(y = fd, x = mpa), color = "blue") +
  geom_point(aes(y = fd.outs, x = mpa), color = "goldenrod")
```

Remove the point that is an obvious outlier at 0 mpa:
```{r}
ignite.only.adfa.epi <- ignite.only.adfa.epi %>% 
 mutate(fd = ifelse(fd > 30, NA, fd))
```

#### pfg

```{r}
outlierKD2(ignite.only.adfa.epi, pfg.outs)
```
```{r}
ignite.only.adfa.epi %>% 
ggplot() +
  geom_point(aes(y =pfg, x = mpa), color = "blue") +
  geom_point(aes(y = pfg.outs, x = mpa), color = "goldenrod")
```
Dont remove
#### fh

```{r}
outlierKD2(ignite.only.adfa.epi, fh.outs)
```
```{r}
ignite.only.adfa.epi %>% 
ggplot() +
  geom_point(aes(y = fh, x = mpa), color = "blue") +
  geom_point(aes(y = fh.outs, x = mpa), color = "goldenrod")
```
#### temp max

```{r}
outlierKD2(ignite.only.adfa.epi, temp.max.outs)
```
```{r}
ignite.only.adfa.epi %>% 
ggplot() +
  geom_point(aes(y = temp.max, x = mpa), color = "blue") +
  geom_point(aes(y = temp.max.outs, x = mpa), color = "goldenrod")
```
Dont remove

#### ignition temp

```{r}
outlierKD2(ignite.only.adfa.epi, ignition.temp.outs)
```
```{r}
ignite.only.adfa.epi %>% 
ggplot() +
  geom_point(aes(y = ignition.temp, x = mpa), color = "blue") +
  geom_point(aes(y = ignition.temp.outs, x = mpa), color = "goldenrod")
```
Look at distributions of flammability metrics so we can think about how
to deal with NAs in those variables, and then deal with them:

First, to visualize NA values in flam metrics: - Ignited samples only,
both models

### Subset data and perform imputations (median):

```{r, include=FALSE}
#str(data)
ignite.only.adfa.epi %>%
  mutate(gti = as.numeric(gti)) 

ignite.only.adfa.epi <- ignite.only.adfa.epi %>%
  group_by(year.month) %>% 
  group_by(spp) %>% #this makes us take the median of based on the species, the model, and the lfm bins (of 10 lfm) the missing value is in. Preserves species differences, and lfm impact. 
  impute_median_at(c("ttfg", "gd", "gti", "fd", "pfg","temp.max", "start.temp", "ros", "ignition.temp", "temp.change", "prop.ignite", "fh", "tti")) 

```

# Repeat with hotplate trials:

```{r}
ignite.only.adfa.hp <- data.adfa %>%
  filter(model == "HP") %>% 
  filter(ignition == "1") %>% 
  dplyr::mutate(gti = replace(gti, gti == "0", "0.5")) %>% #replace when gti is zero to .5 seconds, so we can take the log later
  mutate(gti = as.numeric(gti))
```

### Outliers in flam metrics:

These run and remove outliers automatically, need to quiet the code if
that is not what we want.

#### tti

```{r}
outlierKD2(ignite.only.adfa.hp, tti)
```

#### gti

```{r}
outlierKD2(ignite.only.adfa.hp, gti)
```

#### gd

```{r}
outlierKD2(ignite.only.adfa.hp, gd)
```

#### fd

```{r}
outlierKD2(ignite.only.adfa.hp, fd)
```

#### pfg

```{r}
outlierKD2(ignite.only.adfa.hp, pfg)
```

#### fd

```{r}
outlierKD2(ignite.only.adfa.hp, fh)
```

#### temp.max

```{r}
outlierKD2(ignite.only.adfa.hp, temp.max)
```

#### ignition.temp

```{r}
outlierKD2(ignite.only.adfa.hp, ignition.temp)
```

#### prop.ignite

```{r}
#outlierKD2(ignite.only.adfa.hp, prop.ignite)
```

### Deal with NAs for hotplate:

-   impute medians at each missing flam metric

```{r, include = FALSE}
#str(data)
ignite.only.adfa.hp %>%
  mutate(gti = as.numeric(gti)) 

ignite.only.adfa.hp <- ignite.only.adfa.hp %>%
  group_by(year.month) %>% 
  group_by(spp) %>% #this makes us take the median of based on the species, the model, and the lfm bins (of 10 lfm) the missing value is in. Preserves species differences, and lfm impact. 
  impute_median_at(c("ttfg", "gd", "gti", "fd", "pfg","temp.max", "start.temp", "ros", "ignition.temp", "temp.change", "prop.ignite", "fh", "ros")) %>% 
  impute_lm(fh ~ spp + lfm + fh)  #since fh may have gone out of top of frame for some larger flame height trials, use existing information to impute those values (BUT doesn't really matter since so few fh's are actually missing)
```
# Look at flam characteristics to see if they make sense:

#### For EPI only:

```{r, include=FALSE}

range(ignite.only.adfa.epi$tti)
range(ignite.only.adfa.epi$fh)
#chack for NAs
ignite.only.adfa.epi <- ignite.only.adfa.epi %>%
  mutate(flam.index = 3.1*((86+tti)/(12.5+tti))*exp(fh/(fh+19.5))) #using max tti and max fh, becomes a scale of least (1) to most (20) flammable 

range(ignite.only.adfa.epi$flam.index)
```


#### For HP only:

```{r, include = FALSE}
ignite.only.adfa.hp <- ignite.only.adfa.hp %>%
  mutate(flam.index = 3.45*((214+tti)/(12.5+tti))*exp(fh/(fh+38))) #using max tti and max fh, becomes a scale of least (1) to most (20) flammable
```

Combine both EPI and HP back into master dataset called
"ignite.only.adfa.all"

```{r, include=FALSE}
ignite.only.adfa.all <- rbind(ignite.only.adfa.epi, ignite.only.adfa.hp)
```

### EPI only:

Here we are normalizing by the dry weight of the flammability sample,
which was calculated by multiplying the weight of the burned sample by
the ratio of dry weight to fresh weight in the samples used for lfm
measurements.

(Assumptions here: that the ratio of water to dry weight in burned and
lfm samples was the same)

```{r}
ignite.only.adfa.epi <- ignite.only.adfa.epi %>%  #Dealing with only EPI trials that ignited (can change later)
  dplyr::mutate(mean.wt = mean(sample.wt, na.rm = TRUE)) %>% #take the mean of all sample weights for each model
  ungroup() %>% 
  mutate_if(is.integer, as.numeric) 

ignite.only.adfa.epi$gti <- as.numeric(as.character(ignite.only.adfa.epi$gti)) #not sure why this became a character...
```

```{r, include=FALSE}
ignite.only.adfa.epi <- ignite.only.adfa.epi %>%
  mutate(gti = replace(gti, gti == "0", "0.5")) %>% 
  mutate(gti = as.numeric(gti)) %>%
  mutate("dry.norm.fh" = fh/dw.flam.sample) %>% #create new columns, etc.
  mutate("dry.norm.gd" = gd/dw.flam.sample) %>%
  mutate("dry.norm.fd" = fd/dw.flam.sample) %>%
  mutate("dry.norm.pfg" = pfg/dw.flam.sample) %>%
  mutate("dry.norm.ttfg" = ttfg/dw.flam.sample) %>%
  mutate("dry.norm.tti" = tti/dw.flam.sample) %>% 
  mutate("dry.norm.gti" = gti/dw.flam.sample) 
```


### EPI (USE THIS FOR PCA): Mirroring Max's PCA dataset (Mac_PCA_DATE.Rmd)

```{r, include=FALSE}
epi.ignite.only.adfa.PCA <- ignite.only.adfa.epi %>%
  mutate(mpa = mpa * -1)
colSums(is.na(epi.ignite.only.adfa.PCA))
```

### HP only:

Here we are normalizing by the dry weight of the flammability sample,
which was calculated by multiplying the weight of the burned sample by
the ratio of dry weight to fresh weight in the samples used for lfm
measurements. (Assumptions here: that the ratio of water to dry weight
in burned and lfm samples was the same)

```{r}
ignite.only.adfa.hp <- ignite.only.adfa.hp %>%  #Dealing with only EPI trials that ignited (can change later)
  dplyr::mutate(mean.wt = mean(sample.wt, na.rm = TRUE)) %>% #take the mean of all sample weights for each model
  ungroup() %>% 
  mutate_if(is.integer, as.numeric) 

ignite.only.adfa.hp$gti <- as.numeric(as.character(ignite.only.adfa.hp$gti)) #not sure why this became a character...
```

```{r, include=FALSE}
ignite.only.adfa.hp <- ignite.only.adfa.hp %>%
  mutate(gti = replace(gti, gti == "0", "0.5")) %>% 
  mutate(gti = as.numeric(gti)) %>%
  mutate("dry.norm.fh" = fh/dw.flam.sample) %>% #create new columns, etc.
  mutate("dry.norm.gd" = gd/dw.flam.sample) %>%
  mutate("dry.norm.fd" = fd/dw.flam.sample) %>%
  mutate("dry.norm.pfg" = pfg/dw.flam.sample) %>%
  mutate("dry.norm.ttfg" = ttfg/dw.flam.sample) %>%
  mutate("dry.norm.tti" = tti/dw.flam.sample) %>% 
  mutate("dry.norm.gti" = gti/dw.flam.sample) %>%
  mutate("temp.change" = temp.max - start.temp) 

#str(ignite.only.adfa.hp)
```

### HP (USE THIS FOR PCA): Mirroring Max's PCA dataset (Mac_PCA_DATE.Rmd)

```{r, include=FALSE}
hp.ignite.only.adfa.pca <- ignite.only.adfa.hp %>%
  mutate(mpa = mpa * -1) %>%
  relocate("hydration")

```

------------------------------------------------------------------------

# Combine back into main datasets:

- separated by method

```{r}
no.ignites.ceme.epi <- data.ceme %>%
  filter(ignition == "0") %>% #only look at ignited samples
  filter(model == "EPI")

no.ignites.adfa.epi <- data.adfa %>%
  filter(ignition == "0") %>% #only look at ignited samples
  filter(model == "EPI")

no.ignites.all.epi <- rbind(no.ignites.adfa.epi, no.ignites.ceme.epi)

pca.data.local.noignites <- rbind(no.ignites.adfa.epi, no.ignites.ceme.epi) %>%
  mutate(mpa = mpa * -1) 
```

```{r}
no.ignites.ceme.hp <- data.ceme %>%
  filter(ignition == "0") %>% #only look at ignited samples
  filter(model == "HP")

no.ignites.adfa.hp <- data.adfa %>%
  filter(ignition == "0") %>% #only look at ignited samples
  filter(model == "HP")

no.ignites.all.hp <- rbind(no.ignites.adfa.hp, no.ignites.ceme.hp)

pca.data.local.noignites <- rbind(no.ignites.adfa.hp, no.ignites.ceme.hp) %>%
  mutate(mpa = mpa * -1) 
```


```{r}
pca.data.local.hp.ignited <- rbind(hp.ignite.only.ceme.pca, hp.ignite.only.adfa.pca)

pca.data.local.hp <- pca.data.local.hp.ignited

colSums(is.na(pca.data.local.hp))

pca.data.local.epi.ignites <- rbind(epi.ignite.only.ceme.PCA, epi.ignite.only.adfa.PCA)

pca.data.local.epi <- bind_rows(pca.data.local.epi.ignites, no.ignites.all.epi)

#write.csv(pca.data.local.epi, here("processed-data", "epi.ignite.only.LOCAL.csv"))

colSums(is.na(pca.data.local.epi))

#write.csv(pca.data.local.hp, here("processed-data", "hp.ignite.only.LOCAL.csv"))

#compiled dataset - all dates, all species: 

local_data_all <- rbind(pca.data.local.epi, pca.data.local.hp)
dlookr::diagnose(local_data_all
                 )

write_csv(local_data_all, here("processed-data",  "local_flam_data_all.csv"))
```
